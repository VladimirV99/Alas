<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>IEEE Konverter</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" type="text/css" href="style.css">
  <script type="text/javascript" src="uoar_core.js"></script>
  <script type="text/javascript" src="output.js"></script>
  <script type="text/javascript" src="ieee754.js"></script>
  <script>

    function convertToIEEE754(format, log=true){
      var solution = document.getElementById('solution1');
      if(!solution.classList.contains('hidden'))
        solution.classList.add('hidden');
      clearStackTrace();
      clearOutput();
      addToOutput("<hr>");

      var significand = document.getElementById('input_significand').value;
      var exponent = document.getElementById('input_exponent').value;
      if(significand==""){
        addToStackTrace("convertToIEEE754", "Significand is empty", log);
        return null;
      }
      if(exponent = "")
        exponent = "0";
      significand = toUOARNumber(significand, 10, NumberTypes.SIGNED, false);
      if(significand==null){
        addToStackTrace("convertToIEEE754", "Significand is invalid", log);
        return null;
      }
      
      var res = null;
      switch(format){
        case IEEE754Formats.BINARY32:
          res = convertToIEEE754Binary32(significand, exponent);
          break;
        case IEEE754Formats.BINARY64:
          res = convertToIEEE754Binary64(significand, exponent);
          break;
        case IEEE754Formats.DECIMAL32DPD:
          res = convertToIEEE754Decimal32DPD(significand, exponent);
          break;
        case IEEE754Formats.DECIMAL32BID:
          res = convertToIEEE754Decimal32BID(significand, exponent);
          break;
        case IEEE754Formats.HEXADECIMAL32:
          res = convertToIEEE754Hexadecimal32(significand, exponent);
          break;
        default:
          addToStackTrace("convertToIEEE754", "Invalid operation", log);
          res = null;
      }
      if(res!=null){
        solution.innerHTML=output;
        if(solution.classList.contains('hidden'))
          solution.classList.remove('hidden');
      }
      return res;
    }

    function convertToIEEE754Binary32(significand, exponent, standardized=false, log=true){
      if(significand.number_type!=NumberTypes.SIGNED){
        addToStackTrace("convertToIEEE754Binary32", "Significand isn't signed", log);
        return null;
      }
      if(!standardized){
        significand = standardizeUOARNumber(significand.copy(), false);
        if(significand===null){
          addToStackTrace("convertToIEEE754Binary32", "Invalid significand \"" + significand.toSigned() + "\"", log);
          return null;
        }
      }
      var work1 = "";
      var work2 = "";
      work1 = work1.concat(significand.sign + "(" + significand.toUnsigned() + ")10");
      significand = fromDecimal(significand, 2, true, false);
      work2 = work2.concat(significand.sign + "(" + significand.toUnsigned() + ")2");
      if(significand.whole.length>BINARY32_SIGNIFICAND_LENGTH){
        let res;
        if(significand.sign==PLUS)
          res = new IEEE754Number("0", "11111111", "00000000000000000000000");
        else
          res = new IEEE754Number("1", "11111111", "00000000000000000000000");
        addToOutput(res.toString());
        return res;
      }
      exponent = baseToDecimalInteger(exponent, 10, NumberTypes.SIGNED, false, log);
      if(exponent===null){
        addToStackTrace("convertToIEEE754Binary32", "Invalid exponent \"" + exponent + "\" for base 10", log);
        return null;
      }
      work1 = work1.concat(" * 2^" + exponent);
      work2 = work2.concat(" * 2^" + exponent);

      var normalize_exponent = normalizeBinary(significand, true, log);
      exponent = exponent + normalize_exponent;
      if(!isInBounds(exponent, BINARY32_MIN_EXPONENT, BINARY32_MAX_EXPONENT)){
        addToStackTrace("convertToIEEE754Binary32", "Exponent out of bounds \"" + exponent + "\"", log);
        return null;
      }
      addToOutput(work1 + " = ");
      addToOutput(work2 + " = ");
      addToOutput(significand.sign + "(" + significand.toUnsigned() + ")2 * 2^" + exponent + "<br>");
      significand = fractionToLength(significand, BINARY32_SIGNIFICAND_LENGTH-significand.whole.length, log);

      var res_sign = significand.sign==PLUS ? "0" : "1";
      var res_exponent = toLength(fromDecimal(trimSign(toUOARNumber((BINARY32_EXCESS+exponent).toString(), 10 , NumberTypes.SIGNED, log)), 2, true, log), BINARY32_EXPONENT_LENGTH, 0, log).toUnsigned();
      addToOutput("eksp: " + exponent.toString() + " + " + BINARY32_EXCESS.toString() + " = " + (BINARY32_EXCESS+exponent) + " = (" + res_exponent + ")2 <br>");
      var res_significand = fractionToLength(significand, BINARY32_SIGNIFICAND_LENGTH, log).fraction;
      var res = new IEEE754Number(res_sign, res_exponent, res_significand, IEEE754Formats.BINARY32);
      addToOutput(res.toString());
      return res;
    }

    function convertToIEEE754Binary64(significand, exponent, standardized=false, log=true){
      if(significand.number_type!=NumberTypes.SIGNED){
        addToStackTrace("convertToIEEE754Binary64", "Significand isn't signed", log);
        return null;
      }
      if(!standardized){
        significand = standardizeUOARNumber(significand.copy(), false);
        if(significand===null){
          addToStackTrace("convertToIEEE754Binary64", "Invalid significand \"" + significand.toSigned() + "\"", log);
          return null;
        }
      }
      var work1 = "";
      var work2 = "";
      work1 = work1.concat(significand.sign + "(" + significand.toUnsigned() + ")10");
      significand = fromDecimal(significand, 2, true, false);
      work2 = work2.concat(significand.sign + "(" + significand.toUnsigned() + ")2");
      if(significand.whole.length>BINARY64_SIGNIFICAND_LENGTH){
        if(significand.sign==PLUS)
          return new IEEE754Number("0", "11111111111", "0000000000000000000000000000000000000000000000000000");
        else
          return new IEEE754Number("1", "11111111111", "0000000000000000000000000000000000000000000000000000");
      }
      exponent = baseToDecimalInteger(exponent, 10, NumberTypes.SIGNED, false, log);
      if(exponent===null){
        addToStackTrace("convertToIEEE754Binary64", "Invalid number \"" + exponent + "\" for base 10", log);
        return null;
      }
      work1 = work1.concat(" * 2^" + exponent);
      work2 = work2.concat(" * 2^" + exponent);

      var normalize_exponent = normalizeBinary(significand, true, log);
      exponent = exponent + normalize_exponent; 
      if(!isInBounds(exponent, BINARY64_MIN_EXPONENT, BINARY64_MAX_EXPONENT)){
        addToStackTrace("convertToIEEE754Binary64", "Exponent out of bounds \"" + exponent + "\"", log);
        return null;
      }
      addToOutput(work1 + " = ");
      addToOutput(work2 + " = ");
      addToOutput(significand.sign + "(" + significand.toUnsigned() + ")2 * 2^" + exponent + "<br>");
      significand = fractionToLength(significand, BINARY64_SIGNIFICAND_LENGTH-significand.whole.length, log);

      var res_sign = significand.sign==PLUS ? "0" : "1";
      var res_exponent = toLength(fromDecimal(trimSign(toUOARNumber((BINARY64_EXCESS+exponent).toString(), 10 , NumberTypes.SIGNED, log)), 2, true, log), BINARY64_EXPONENT_LENGTH, 0, log).toUnsigned();
      addToOutput("eksp: " + exponent.toString() + " + " + BINARY64_EXCESS.toString() + " = " + (BINARY64_EXCESS+exponent) + " = (" + res_exponent + ")2 <br>");
      var res_significand = fractionToLength(significand, BINARY64_SIGNIFICAND_LENGTH, log).fraction;
      var res = new IEEE754Number(res_sign, res_exponent, res_significand, IEEE754Formats.BINARY64);
      addToOutput(res.toString());
      return res;
    }

    function convertToIEEE754Decimal32DPD(significand, exponent, standardized=false, log=true){
      if(significand.number_type!=NumberTypes.SIGNED){
        addToStackTrace("convertToIEEE754Decimal32DPD", "Significand isn't signed", log);
        return null;
      }
      if(!standardized){
        significand = standardizeUOARNumber(significand.copy(), false);
        if(significand===null){
          addToStackTrace("convertToIEEE754Decimal32DPD", "Invalid significand \"" + significand.toSigned() + "\"", log);
          return null;
        }
      }
      if(significand.whole.length>DECIMAL32_SIGNIFICAND_LENGTH){
        if(significand.sign==PLUS)
          return new IEEE754Number("0", "11110000000", "00000000000000000000");
        else
          return new IEEE754Number("1", "11110000000", "00000000000000000000");
      }
      exponent = baseToDecimalInteger(exponent, 10, NumberTypes.SIGNED, false, log);
      if(exponent===null){
        addToStackTrace("convertToIEEE754Decimal32DPD", "Invalid number \"" + exponent + "\" for base 10", log);
        return null;
      }
      var work1 = significand.sign + "(" + significand.toUnsigned() + ")10 * 10^" + exponent;

      var normalize_exponent = normalizeDecimal(significand, true, log);
      exponent = exponent + normalize_exponent; 
      if(!isInBounds(exponent, DECIMAL32_MIN_EXPONENT, DECIMAL32_MAX_EXPONENT)){
        addToStackTrace("convertToIEEE754Decimal32DPD", "Exponent out of bounds \"" + exponent + "\"", log);
        return null;
      }

      significand = wholeToLength(significand, DECIMAL32_DIGITS, log);
      if(significand===null){
        addToStackTrace("convertToIEEE754Decimal32DPD", "Significand out of bounds \"" + significand.toSigned() + "\"", log);
        return null;
      }
      addToOutput(work1 + " = ");
      addToOutput(significand.sign + "(" + significand.toUnsigned() + ")10 * 10^" + exponent + "<br>");

      var res_sign = significand.sign==PLUS ? "0" : "1";
      var res_exponent;
      var na = addZeroesBefore(digitToBinary(significand.whole, 0), 10, NumberTypes.UNSIGNED, 4, log);
      var nb = wholeToLength(fromDecimal(trimSign(toUOARNumber((DECIMAL32_EXCESS+exponent).toString(), 10, NumberTypes.SIGNED, log)), 2, true, log), 8, log).toUnsigned();
      addToOutput("eksp: " + exponent.toString() + " + " + DECIMAL32_EXCESS.toString() + " = " + (DECIMAL32_EXCESS+exponent) + " = (" + nb + ")2 <br>");
      if(na.charAt(0)=='0'){
        addToOutput("komb: " + nb.substr(0,2) + " " + na.substr(1,3) + " " + nb.substr(2,6) + "<br>");
        res_exponent = nb.substr(0,2)+na.substr(1,3)+nb.substr(2,6);
      }else{
        addToOutput("komb: 11 " + nb.substr(0, 2) + na.charAt(3) + " " +nb.substr(2, 6));
        res_exponent = "11"+nb.substr(0, 2)+na.charAt(3)+nb.substr(2, 6);
      }
      var res_significand;
      addToOutput("<table>");
      addToOutput("<tr>");
      for(let i=1; i<=6; i++){
        addToOutput("<td>" + significand.whole.charAt(i) + "</td>");
      }
      addToOutput("</tr>");
      addToOutput("<tr>");
      for(let i=1; i<=6; i++){
        addToOutput("<td>" + addZeroesBefore(numberToBinary(significand.whole.charAt(i), log), 2, NumberTypes.UNSIGNED, 4, log) + "</td>");
      }
      addToOutput("</tr>");
      var nc1 = decimalToDPD(decimalTo8421(significand.whole.substr(1, 3)));
      var nc2 = decimalToDPD(decimalTo8421(significand.whole.substr(4, 3)));
      addToOutput("<tr><td colspan=\"3\">" + nc1 + "</td><td colspan=\"3\">" + nc2 + "</td></tr>");
      addToOutput("</table><br>");
      res_significand = nc1 + nc2;
      var res = new IEEE754Number(res_sign, res_exponent, res_significand, IEEE754Formats.DECIMAL32DPD);
      addToOutput(res);
      return res;
    }

    function convertToIEEE754Decimal32BID(significand, exponent, standardized=false, log=true){
      if(significand.number_type!=NumberTypes.SIGNED){
        addToStackTrace("convertToIEEE754Decimal32BID", "Significand isn't signed", log);
        return null;
      }
      if(!standardized){
        significand = standardizeUOARNumber(significand.copy(), false);
        if(significand===null){
          addToStackTrace("convertToIEEE754Decimal32BID", "Invalid significand \"" + significand.toSigned() + "\"", log);
          return null;
        }
      }
      if(significand.whole.length>DECIMAL32_SIGNIFICAND_LENGTH){
        if(significand.sign==PLUS)
          return new IEEE754Number("0", "11110000000", "00000000000000000000");
        else
          return new IEEE754Number("1", "11110000000", "00000000000000000000");
      }
      exponent = baseToDecimalInteger(exponent, 10, NumberTypes.SIGNED, false, log);
      if(exponent===null){
        addToStackTrace("convertToIEEE754Decimal32BID", "Invalid number \"" + exponent + "\" for base 10", log);
        return null;
      }
      var work1 = significand.sign + "(" + significand.toUnsigned() + ")10 * 10^" + exponent;

      var normalize_exponent = normalizeDecimal(significand, true, log);
      exponent = exponent + normalize_exponent; 
      if(!isInBounds(exponent, DECIMAL32_MIN_EXPONENT, DECIMAL32_MAX_EXPONENT)){
        addToStackTrace("convertToIEEE754Decimal32BID", "Exponent out of bounds \"" + exponent + "\"", log);
        return null;
      }
      addToOutput(work1 + " = ");
      addToOutput(significand.sign+ "(" + significand.toUnsigned() + ")10 * 10^" + exponent + " = ");

      significand = wholeToLength(fromDecimal(significand, 2, true, log), 1+BINARY32_SIGNIFICAND_LENGTH, log);
      if(significand===null){
        addToStackTrace("convertToIEEE754Decimal32BID", "Significand out of bounds \"" + significand.toSigned() + "\"", log);
        return null;
      }
      addToOutput(significand.sign + "(" + significand.toUnsigned() + ")2 * 10^" + exponent + "<br>");

      var res_sign = significand.sign==PLUS ? "0" : "1";
      var res_exponent;
      var na = significand.whole.substr(0,4);
      var nb = wholeToLength(fromDecimal(trimSign(toUOARNumber((DECIMAL32_EXCESS+exponent).toString(), 10, NumberTypes.SIGNED, log)), 2, true, log), 8, log).toUnsigned();
      addToOutput("eksp: " + exponent.toString() + " + " + DECIMAL32_EXCESS.toString() + " = " + (DECIMAL32_EXCESS+exponent) + " = (" + nb + ")2 <br>");
      if(na.charAt(0)=='0'){
        addToOutput("komb: " + nb + " " + na.substr(1,3) + "<br>");
        res_exponent = nb+na.substr(1,3);
      }else{
        addToOutput("komb: 11 " + nb + " " + na.charAt(3));
        res_exponent = "11"+nb+na.charAt(3);
      }
      var res_significand = significand.whole.substr(4);
      var res = new IEEE754Number(res_sign, res_exponent, res_significand, IEEE754Formats.DECIMAL32BID);
      addToOutput(res);
      return res;
    }

    function convertToIEEE754Hexadecimal32(significand, exponent, standardized=false, log=true){
      if(significand.number_type!=NumberTypes.SIGNED){
        addToStackTrace("convertToIEEE754Hexadecimal32", "Significand isn't signed", log);
        return null;
      }
      if(!standardized){
        significand = standardizeUOARNumber(significand.copy(), false);
        if(significand===null){
          addToStackTrace("convertToIEEE754Hexadecimal32", "Invalid significand \"" + significand.toSigned() + "\"", log);
          return null;
        }
      }
      if(significand.whole.length>HEXADECIMAL32_SIGNIFICAND_LENGTH){
        if(significand.sign==PLUS)
          return new IEEE754Number("0", "11111111", "00000000000000000000000");
        else
          return new IEEE754Number("1", "11111111", "00000000000000000000000");
      }
      var work1 = "";
      var work2 = "";
      work1 = work1.concat(significand.sign + "(" + significand.toUnsigned() + ")10");
      significand = fromDecimal(significand, 16, true, log);
      work2 = work2.concat(significand.sign + "(" + significand.toUnsigned() + ")16");
      exponent = baseToDecimalInteger(exponent, 10, NumberTypes.SIGNED, false, log);
      if(exponent===null){
        addToStackTrace("convertToIEEE754Hexadecimal32", "Invalid number \"" + exponent + "\" for base 10", log);
        return null;
      }
      work1 = work1.concat(" * 16^" + exponent);
      work2 = work2.concat(" * 16^" + exponent);

      var normalize_exponent = normalizeHexadecimal(significand, true, log);
      exponent = exponent + normalize_exponent; 
      if(!isInBounds(exponent, HEXADECIMAL32_MIN_EXPONENT, HEXADECIMAL32_MAX_EXPONENT)){
        addToStackTrace("convertToIEEE754Hexadecimal32", "Exponent out of bounds \"" + exponent + "\"", log);
        return null;
      }
      addToOutput(work1 + " = ");
      addToOutput(work2 + " = ");
      addToOutput(significand.sign + "(" + significand.toUnsigned() + ")16 * 16^" + exponent + "<br>");

      var res_sign = significand.sign==PLUS ? "0" : "1";
      var res_exponent = toLength(fromDecimal(trimSign(toUOARNumber((HEXADECIMAL32_EXCESS+exponent).toString(), 10, NumberTypes.SIGNED, log)), 2, true, log), HEXADECIMAL32_EXPONENT_LENGTH, 0, log).toUnsigned();
      addToOutput("eksp: " + exponent.toString() + " + " + HEXADECIMAL32_EXCESS + " = " + (HEXADECIMAL32_EXCESS+exponent) + " = (" + res_exponent + ")2 <br>");
      var res_significand = decimalTo8421(significand.fraction);
      var res = new IEEE754Number(res_sign, res_exponent, res_significand, IEEE754Formats.HEXADECIMAL32);
      addToOutput(res);
      return res;
    }

    function convertFromIEEE754(format, log=true){
      var solution = document.getElementById('solution2');
      if(!solution.classList.contains('hidden'))
        solution.classList.add('hidden');
      clearStackTrace();
      clearOutput();
      addToOutput("<hr>");

      var ieee = document.getElementById('input_ieee754').value.toString();
      var res = null;
      switch(format){
        case IEEE754Formats.BINARY32:
          ieee = toIEEE754Number(ieee, IEEE754Formats.BINARY32, false);
          if(ieee!=null){
            res = convertFromIEEE754Binary32(ieee);
          }
          break;
        case IEEE754Formats.BINARY64:
          ieee = toIEEE754Number(ieee, IEEE754Formats.BINARY64, false);
          if(ieee!=null){
            res = convertFromIEEE754Binary64(ieee);
          }
          break;
        case IEEE754Formats.DECIMAL32DPD:
          ieee = toIEEE754Number(ieee, IEEE754Formats.DECIMAL32DPD, false);
          if(ieee!=null){
            res = convertFromIEEE754Decimal32DPD(ieee);
          }
          break;
        case IEEE754Formats.DECIMAL32BID:
          ieee = toIEEE754Number(ieee, IEEE754Formats.DECIMAL32BID, false);
          if(ieee!=null){
            res = convertFromIEEE754Decimal32BID(ieee);
          }
          break;
        case IEEE754Formats.HEXADECIMAL32:
          ieee = toIEEE754Number(ieee, IEEE754Formats.HEXADECIMAL32, false);
          if(ieee!=null){
            res = convertFromIEEE754Hexadecimal32(ieee);
          }
          break;
        default:
          addToStackTrace("convertFromIEEE754", "Invalid operation", log);
          res = null;
      }
      if(ieee==null){
        addToStackTrace("convertFromIEEE754", "Invalid Number", log);
        return null;
      }
      if(res!=null){
        solution.innerHTML=output;
        if(solution.classList.contains('hidden'))
          solution.classList.remove('hidden');
      }
      return res;
    }

    function convertFromIEEE754Binary32(number, log=true){
      if(!isValidIEEE754(number, IEEE754Formats.BINARY32)){
        addToStackTrace("convertFromIEEE754Binary32", "Invalid IEEE754 Binary32 number \"" + number + "\"", log);
        return null;
      }

      var res = getSpecialValueBinary32(number);
      if(res!=null){
        addToOutput("specijalna vrednost: " + res.toString() + "<br>");
        return res;
      }

      var sign = number.sign=="0" ? PLUS : MINUS;
      var significand;
      var exponent = baseToDecimalInteger(number.exponent, 2, NumberTypes.UNSIGNED, log);
      addToOutput("eksp: (" + number.exponent + ")2 - " + BINARY32_EXCESS.toString() + " = " + exponent + " - " + BINARY32_EXCESS.toString() + " = ");
      exponent -= BINARY32_EXCESS;
      addToOutput(exponent + "<br>");

      if(exponent==-BINARY32_EXCESS){
        addToOutput("subnormalan broj<br>");
        significand = trimNumber(new UOARNumber(sign, "0", number.significand, 2, NumberTypes.SIGNED));
        addToOutput("(" + significand.toSigned() + ")2 * 2^" + (exponent+1) + " = ");
        exponent += 1+normalizeBinary(significand, true, log);
      }else{
        significand = trimNumber(new UOARNumber(sign, "1", number.significand, 2, NumberTypes.SIGNED));
        addToOutput("frakc: (" + significand.toSigned() + ")2<br>");
      }

      var whole = significand.whole!="0";
      var len = (whole? 1 : 0) + significand.fraction.length;
      if(len!=1){
        if(!whole)
          significand.whole="";
        if(exponent>=0 && exponent<10){
          significand.whole = significand.whole.concat(significand.fraction.substr(0, exponent));
          significand.fraction = significand.fraction.substr(exponent);
          exponent = 0;
        }else{
          if(len<9){
            exponent -= significand.fraction.length;
            significand.whole = significand.whole.concat(significand.fraction);
            significand.fraction = "";
          }else if(len<14){
            exponent -= 8-(whole? 1 : 0);
            significand.whole = significand.whole.concat(significand.fraction.substr(0, 8-(whole? 1 : 0)));
            significand.fraction = significand.fraction.substr(8-(whole? 1 : 0));
          }else{
            exponent -= len-5-(whole? 1 : 0);
            significand.whole = significand.whole.concat(significand.fraction.substr(0, len-5-(whole? 1 : 0)));
            significand.fraction = significand.fraction.substr(len-5-(whole? 1 : 0));
          }
        }
      }
      addToOutput("(" + significand.toSigned() + ")2 * 2^" + exponent + " = ");
      significand = toDecimal(significand, true, log);
      addToOutput("(" + significand.toSigned() + ")2 * 2^" + exponent + "<br>");
      return new SignificandExponentPair(significand, 2, exponent);
    }

    function convertFromIEEE754Binary64(number, log=true){
      if(!isValidIEEE754(number, IEEE754Formats.BINARY64)){
        addToStackTrace("convertFromIEEE754Binary64", "Invalid IEEE754 Binary64 number \"" + number + "\"", log);
        return null;
      }

      var res = getSpecialValueBinary64(number);
      if(res!=null){
        addToOutput("specijalna vrednost: " + res.toString() + "<br>");
        return res;
      }

      var sign = number.sign=="0" ? PLUS : MINUS;
      var significand;
      var exponent = baseToDecimalInteger(number.exponent, 2, NumberTypes.UNSIGNED, log);
      addToOutput("eksp: (" + number.exponent + ")2 - " + BINARY32_EXCESS.toString() + " = " + exponent + " - " + BINARY32_EXCESS.toString() + " = ");
      exponent -= BINARY64_EXCESS;
      addToOutput(exponent + "<br>");

      if(exponent==-BINARY64_EXCESS){
        addToOutput("subnormalan broj<br>");
        significand = trimNumber(new UOARNumber(sign, "0", number.significand, 2, NumberTypes.SIGNED));
        addToOutput("(" + significand.toSigned() + ")2 * 2^" + (exponent+1) + " = ");
        exponent += 1+normalizeBinary(significand, true, log);
      }else{
        significand = trimNumber(new UOARNumber(sign, "1", number.significand, 2, NumberTypes.SIGNED));
        addToOutput("frakc: (" + significand.toSigned() + ")2<br>");
      }

      var whole = significand.whole!="0";
      var len = (whole? 1 : 0) + significand.fraction.length;
      if(len!=1){
        if(!whole)
          significand.whole="";
        if(exponent>=0 && exponent<10){
          significand.whole = significand.whole.concat(significand.fraction.substr(0, exponent));
          significand.fraction = significand.fraction.substr(exponent);
          exponent = 0;
        }else{
          if(len<9){
            exponent -= significand.fraction.length;
            significand.whole = significand.whole.concat(significand.fraction);
            significand.fraction = "";
          }else if(len<14){
            exponent -= 8-(whole? 1 : 0);
            significand.whole = significand.whole.concat(significand.fraction.substr(0, 8-(whole? 1 : 0)));
            significand.fraction = significand.fraction.substr(8-(whole? 1 : 0));
          }else{
            exponent -= len-5-(whole? 1 : 0);
            significand.whole = significand.whole.concat(significand.fraction.substr(0, len-5-(whole? 1 : 0)));
            significand.fraction = significand.fraction.substr(len-5-(whole? 1 : 0));
          }
        }
      }
      addToOutput("(" + significand.toSigned() + ")2 * 2^" + exponent + " = ");
      significand = toDecimal(significand, true, log);
      addToOutput("(" + significand.toSigned() + ")2 * 2^" + exponent + "<br>");
      return new SignificandExponentPair(significand, 2, exponent);
    }

    function convertFromIEEE754Decimal32DPD(number, log=true){
      if(!isValidIEEE754(number, IEEE754Formats.DECIMAL32DPD)){
        addToStackTrace("convertFromIEEE754Decimal32DPD", "Invalid IEEE754 Decimal32 number \"" + number + "\"", log);
        return null;
      }

      var res = getSpecialValueDecimal32(number);
      if(res!=null){
        addToOutput("specijalna vrednost: " + res.toString() + "<br>");
        return res;
      }

      var sign = number.sign=="0" ? PLUS : MINUS;
      var significand;
      var comb = "";
      if(number.exponent.substr(0, 2)=="11"){
        significand = "100" + number.exponent.charAt(4);
        comb = number.exponent.substr(2, 2) + number.exponent.substr(5, 6);
      }else{
        significand = "0" + number.exponent.substr(2, 3);
        comb = number.exponent.substr(0,2) + number.exponent.substr(5, 6);
      }

      var exponent = baseToDecimalInteger(comb, 2, NumberTypes.UNSIGNED, log);
      if(exponent==0){
        addToOutput("subnormalan broj<br>");
        exponent = -DECIMAL32_EXCESS - DECIMAL32_DIGITS;
        addToOutput("eksp: " + exponent + "<br>");
      }else{
        addToOutput("eksp: (" + comb + ")2 - " + DECIMAL32_EXCESS + " = " + exponent + " - " + DECIMAL32_EXCESS + " = ");
        exponent -= DECIMAL32_EXCESS;
        addToOutput(exponent + "<br>");
      }

      let dpd1 = DPDtoDecimal(number.significand.substr(0, DECIMAL32_TRIPLET_LENGTH), log);
      let dpd2 = DPDtoDecimal(number.significand.substr(DECIMAL32_TRIPLET_LENGTH, DECIMAL32_TRIPLET_LENGTH), log);
      addToOutput("frakc: (" + significand + " " + dpd1 + " " + dpd2 + ")2 = ");
      significand = significand + dpd1 + dpd2;
      significand = trimNumber(new UOARNumber(sign, decimalFrom8421(significand, log), "", 10, NumberTypes.SIGNED));
      addToOutput("(" + significand.toUnsigned() + ")10 <br>");

      addToOutput("(" + significand.toSigned() + ")10 * 10^" + exponent);
      var normalize_exponent = normalizeDecimal(significand, true, log);
      if(normalize_exponent>0){
        exponent += normalize_exponent;
        addToOutput(" = (" + significand.toSigned() + ")10 * 10^" + exponent + "<br>");
      }

      return new SignificandExponentPair(significand, 10, exponent);
    }

    function convertFromIEEE754Decimal32BID(number, log=true){
      if(!isValidIEEE754(number, IEEE754Formats.DECIMAL32BID)){
        addToStackTrace("convertFromIEEE754Decimal32BID", "Invalid IEEE754 Decimal32 number \"" + number + "\"", log);
        return null;
      }

      var res = getSpecialValueDecimal32(number);
      if(res!=null){
        return res;
      }

      var sign = number.sign=="0" ? PLUS : MINUS;
      var significand;
      var comb = "";
      if(number.exponent.substr(0, 2)=="11"){
        significand = "100" + number.exponent.charAt(10);
        comb = number.exponent.substr(2, 8);
      }else{
        significand = "0" + number.exponent.substr(8, 3);
        comb = number.exponent.substr(0,8);
      }

      var exponent = baseToDecimalInteger(comb, 2, NumberTypes.UNSIGNED, log);
      if(exponent==0){
        addToOutput("subnormalan broj<br>");
        exponent = -DECIMAL32_EXCESS - DECIMAL32_DIGITS;
        addToOutput("eksp: " + exponent + "<br>");
      }else{
        addToOutput("eksp: (" + comb + ")2 - " + DECIMAL32_EXCESS + " = " + exponent + " - " + DECIMAL32_EXCESS + " = ");
        exponent -= DECIMAL32_EXCESS;
        addToOutput(exponent + "<br>");
      }

      addToOutput("frakc: (" + significand + " " + number.significand + ")2 = ");
      significand = significand + number.significand;
      significand = toDecimal(new UOARNumber(sign, significand, "", 2, NumberTypes.SIGNED), false, log);
      addToOutput("(" + significand.toUnsigned() + ")10 <br>");

      addToOutput("(" + significand.toSigned() + ")10 * 10^" + exponent);
      var normalize_exponent = normalizeDecimal(significand, true, log);
      if(normalize_exponent>0){
        exponent += normalize_exponent;
        addToOutput(" = (" + significand.toSigned() + ")10 * 10^" + exponent + "<br>");
      }

      return new SignificandExponentPair(significand, 10, exponent);
    }

    function convertFromIEEE754Hexadecimal32(number, log=true){
      if(!isValidIEEE754(number, IEEE754Formats.HEXADECIMAL32)){
        addToStackTrace("convertFromIEEE754Hexadecimal32", "Invalid IEEE754 Hexadecimal32 number \"" + number + "\"", log);
        return null;
      }

      var sign = number.sign=="0" ? PLUS : MINUS;
      var significand = trimNumber(new UOARNumber(sign, "0", decimalFrom8421(number.significand), 16, NumberTypes.SIGNED));
      var exponent = baseToDecimalInteger(number.exponent, 2, NumberTypes.UNSIGNED, log);
      addToOutput("eksp: (" + number.exponent + ")2 - " + HEXADECIMAL32_EXCESS.toString() + " = " + exponent + " - " + HEXADECIMAL32_EXCESS + " = ");
      exponent -= HEXADECIMAL32_EXCESS;
      addToOutput(exponent + "<br>");

      addToOutput("frakc: (0." + number.significand + ")2 = (" + significand.toUnsigned() + ")16 <br>");
      addToOutput("(" + significand.toUnsigned() + ")16 * 16^" + exponent + " = ");

      var len = significand.fraction.length;
      if(exponent>=0 && exponent<6){
        significand.whole = significand.fraction.substr(0, exponent);
        significand.fraction = significand.fraction.substr(exponent);
        exponent = 0;
      }else{
        if(len<6){
          exponent += significand.fraction.length;
          significand.whole = significand.fraction;
          significand.fraction = "";
        }else if(len<9){
          exponent -= 6;
          significand.whole = significand.fraction.substr(0, 6);
          significand.fraction = significand.fraction.substr(6);
        }else{
          exponent -= len-3;
          significand.whole = significand.fraction.substr(0, len-3);
          significand.fraction = significand.fraction.substr(len-3);
        }
      }
      addToOutput("(" + significand.toUnsigned() + ")16 * 16^" + exponent + " = ");
      significand = toDecimal(significand, false, log);
      addToOutput("(" + significand.toUnsigned() + ")10 * 16^" + exponent);
      return new SignificandExponentPair(significand, 16, exponent);
    }

    function doOperation(operation, log=true){
      var solution = document.getElementById('solution3');
      if(!solution.classList.contains('hidden'))
        solution.classList.add('hidden');
      clearStackTrace();
      clearOutput();
      addToOutput("<hr>");

      operand1 = document.getElementById("input_operand1").value;
      operand2 = document.getElementById("input_operand2").value;
      if(operand1=="" || operand2==""){
        addToStackTrace("doOperation", "Empty Operand", log)
        return null;
      }
      operand1 = toIEEE754Number(operand1, IEEE754Formats.BINARY32, false);
      operand2 = toIEEE754Number(operand2, IEEE754Formats.BINARY32, false);

      var res;
      switch(operation){
        case ArithmeticOperations.ADDITION:
          res = addIEEE754(operand1, operand2, log);
          break;
        case ArithmeticOperations.SUBTRACTION:
          res = subtractIEEE754(operand1, operand2, log);
          break;
        case ArithmeticOperations.MULTIPLICATION:
          res = multiplyIEEE754(operand1, operand2, log);
          break;
        case ArithmeticOperations.DIVISION:
          res = divideIEEE754(operand1, operand2, log);
          break;
        default:
          addToStackTrace("doOperation", "Invalid operation", log);
          res = null;
      }
      if(res!=null){
        solution.innerHTML=output;
        if(solution.classList.contains('hidden'))
          solution.classList.remove('hidden');
      }
      return res;
    }

    function addIEEE754(operand1, operand2, log=true){
      if(operand1==null || operand2==null || operand1.format!=IEEE754Formats.BINARY32 || operand2.format!=IEEE754Formats.BINARY32 || !isValidIEEE754(operand1) || !isValidIEEE754(operand2)){
        addToStackTrace("addIEEE754", "Invalid operands", log);
        return null;
      }

      var special1 = getSpecialValueBinary32(operand1);
      var special2 = getSpecialValueBinary32(operand2);
      if(special1!=null || special2!=null){
        if(special1==QNAN || special2==QNAN){
          addToOutput("x + "+QNAN.toString()+" = "+QNAN.toString());
          return BINARY32_QNAN;
        } else if(special1==SNAN || special2==SNAN){
          addToOutput("x + "+SNAN.toString()+" = "+QNAN.toString());
          return BINARY32_QNAN;
        }else if(special1==POS_INF && special2==NEG_INF){
          addToOutput(POS_INF.toString()+" + "+NEG_INF.toString()+" = "+QNAN.toString());
          return BINARY32_QNAN;
        }else if(special1==NEG_INF && special2==POS_INF){
          addToOutput(NEG_INF.toString()+" + "+POS_INF.toString()+" = "+QNAN.toString());
          return BINARY32_QNAN;
        }else if(special1==POS_INF && special2==POS_INF){
          addToOutput(POS_INF.toString()+" + "+POS_INF.toString()+" = "+POS_INF.toString());
          return BINARY32_POS_INF;
        }else if(special1==NEG_INF && special2==NEG_INF){
          addToOutput(NEG_INF.toString()+" + "+NEG_INF.toString()+" = "+NEG_INF.toString());
          return BINARY32_NEG_INF;
        }else if((special1==POS_INF && special2!=NEG_INF) || (special2==POS_INF && special1!=NEG_INF)){
          addToOutput("x + "+POS_INF.toString()+" = "+POS_INF.toString());
          return BINARY32_POS_INF;
        }else if((special1==NEG_INF && special2!=POS_INF) || (special2==NEG_INF && special1!=POS_INF)){
          addToOutput("x + "+NEG_INF.toString()+" = "+NEG_INF.toString());
          return BINARY32_NEG_INF;
        }
      }

      var exponent1 = baseToDecimalInteger(operand1.exponent, 2, NumberTypes.UNSIGNED, false);
      var exponent2 = baseToDecimalInteger(operand2.exponent, 2, NumberTypes.UNSIGNED, false);
      var exponent = Math.min(exponent1, exponent2);
      addToOutput("eksp: " + exponent + " = " + BINARY32_EXCESS + " + " + (exponent-BINARY32_EXCESS) + "<br>");
      exponent1 -= exponent;
      exponent2 -= exponent;

      var significand1 = trimNumber(new UOARNumber(operand1.sign=="0"?PLUS:MINUS, (exponent==0?"0":"1")+operand1.significand.substr(0, exponent1), operand1.significand.substr(exponent1), 2, NumberTypes.SIGNED));
      var significand2 = trimNumber(new UOARNumber(operand2.sign=="0"?PLUS:MINUS, (exponent==0?"0":"1")+operand2.significand.substr(0, exponent2), operand2.significand.substr(exponent2), 2, NumberTypes.SIGNED));
      addToOutput("frakc:<br>");
      addToOutput("<table id=\"calculation\"><tr><td class=\"sign\">"+significand1.sign+"</td><td class=\"whole\">"+significand1.whole+".</td><td class=\"fraction\">"+significand1.fraction+"</td></tr>");
      addToOutput("<tr><td class=\"sign\">"+significand2.sign+"</td><td class=\"whole\">"+significand2.whole+".</td><td>"+significand2.fraction+"</td class=\"fraction\"></tr>");

      var significand = add(significand1, significand2, NumberTypes.SIGNED, true, false);
      addToOutput("<tr><td class=\"sign\">"+significand.sign+"</td><td class=\"whole\">"+significand.whole+".</td><td class=\"fraction\">"+significand.fraction+"</td></table>");
      
      addToOutput("(" + significand.toSigned() + ")2 * 2^" + (exponent-BINARY32_EXCESS));
      var normalize_exponent = normalizeBinary(significand, true, false);
      exponent += normalize_exponent;
      if(normalize_exponent!=0)
        addToOutput(" = (" + significand.toSigned() + ")2 * 2^" + (exponent-BINARY32_EXCESS));
      if(exponent > BINARY32_MAX_EXPONENT+BINARY32_EXCESS){
        if(significand.sign==PLUS){
          addToOutput("+Inf");
          return POS_INF;
        }else{
          addToOutput("-Inf");
          return NEG_INF;
        }
      } else if(exponent <= 0){
        significand.fraction = createZeroString(-exponent-1) + significand.whole + significand.fraction;
        significand.whole = "0";
        addToOutput("<br>");
        addToOutput("subnormalan broj: " + significand.toSigned());
      }
      addToOutput("<br>");

      addToOutput("znak: " + (significand.sign==PLUS?"0":"1") + "<br>");

      significand = fractionToLength(significand, BINARY32_SIGNIFICAND_LENGTH, false);
      exponent = toLength(fromDecimal(trimSign(toUOARNumber(exponent.toString(), 10 , NumberTypes.UNSIGNED, log)), 2, true, log), BINARY32_EXPONENT_LENGTH, 0, log).toUnsigned();

      var res = new IEEE754Number(significand.sign==PLUS?"0":"1", exponent, significand.fraction, IEEE754Formats.BINARY32);
      addToOutput(res.toString());
      return res;
    }

    function subtractIEEE754(log=true){
      if(operand1==null || operand2==null || operand1.format!=IEEE754Formats.BINARY32 || operand2.format!=IEEE754Formats.BINARY32 || !isValidIEEE754(operand1) || !isValidIEEE754(operand2)){
        addToStackTrace("subtractIEEE754", "Invalid operands", log);
        return null;
      }

      var special1 = getSpecialValueBinary32(operand1);
      var special2 = getSpecialValueBinary32(operand2);
      if(special1!=null || special2!=null){
        if(special1==QNAN || special2==QNAN){
          addToOutput("x - "+QNAN.toString()+" = "+QNAN.toString());
          return BINARY32_QNAN;
        } else if(special1==SNAN || special2==SNAN){
          addToOutput("x - "+SNAN.toString()+" = "+QNAN.toString());
          return BINARY32_QNAN;
        }else if(special1==POS_INF && special2==POS_INF){
          addToOutput(POS_INF.toString()+" - "+POS_INF.toString()+" = "+QNAN.toString());
          return BINARY32_QNAN;
        }else if(special1==NEG_INF && special2==NEG_INF){
          addToOutput(NEG_INF.toString()+" - "+NEG_INF.toString()+" = "+QNAN.toString());
          return BINARY32_QNAN;
        }else if(special1==POS_INF && special2==NEG_INF){
          addToOutput(POS_INF.toString()+" - "+NEG_INF.toString()+" = "+POS_INF.toString());
          return BINARY32_POS_INF;
        }else if(special1==NEG_INF && special2==POS_INF){
          addToOutput(NEG_INF.toString()+" - "+POS_INF.toString()+" = "+NEG_INF.toString());
          return BINARY32_NEG_INF;
        }else if(special1==POS_INF && special2!=POS_INF){
          addToOutput(POS_INF.toString()+" - x = "+POS_INF.toString());
          return BINARY32_POS_INF;
        }else if(special2==NEG_INF && special1!=NEG_INF){
          addToOutput("x - "+NEG_INF.toString()+" = "+POS_INF.toString());
          return BINARY32_POS_INF;
        }else if(special1==NEG_INF && special2!=NEG_INF){
          addToOutput(NEG_INF.toString()+" - x = "+NEG_INF.toString());
          return BINARY32_NEG_INF;
        }else if(special2==POS_INF && special1!=POS_INF){
          addToOutput("x - "+POS_INF.toString()+" = "+NEG_INF.toString());
          return BINARY32_NEG_INF;
        }
      }

      var exponent1 = baseToDecimalInteger(operand1.exponent, 2, NumberTypes.UNSIGNED, false);
      var exponent2 = baseToDecimalInteger(operand2.exponent, 2, NumberTypes.UNSIGNED, false);
      var exponent = Math.min(exponent1, exponent2);
      addToOutput("eksp: " + exponent + " = " + BINARY32_EXCESS + " + " + (exponent-BINARY32_EXCESS) + "<br>");
      exponent1 -= exponent;
      exponent2 -= exponent;

      var significand1 = trimNumber(new UOARNumber(operand1.sign=="0"?PLUS:MINUS, (exponent==0?"0":"1")+operand1.significand.substr(0, exponent1), operand1.significand.substr(exponent1), 2, NumberTypes.SIGNED));
      var significand2 = trimNumber(new UOARNumber(operand2.sign=="0"?PLUS:MINUS, (exponent==0?"0":"1")+operand2.significand.substr(0, exponent2), operand2.significand.substr(exponent2), 2, NumberTypes.SIGNED));
      significand2.sign = significand2.sign==PLUS ? MINUS : PLUS;
      addToOutput("frakc:<br>");
      addToOutput("<table id=\"calculation\"><tr><td class=\"sign\">"+significand1.sign+"</td><td class=\"whole\">"+significand1.whole+".</td><td class=\"fraction\">"+significand1.fraction+"</td></tr>");
      addToOutput("<tr><td class=\"sign\">"+significand2.sign+"</td><td class=\"whole\">"+significand2.whole+".</td><td>"+significand2.fraction+"</td class=\"fraction\"></tr>");

      var significand = add(significand1, significand2, NumberTypes.SIGNED, true, false);
      addToOutput("<tr><td class=\"sign\">"+significand.sign+"</td><td class=\"whole\">"+significand.whole+".</td><td class=\"fraction\">"+significand.fraction+"</td></table>");
      
      addToOutput("(" + significand.toSigned() + ")2 * 2^" + (exponent-BINARY32_EXCESS));
      var normalize_exponent = normalizeBinary(significand, true, false);
      exponent += normalize_exponent;
      if(normalize_exponent!=0)
        addToOutput(" = (" + significand.toSigned() + ")2 * 2^" + (exponent-BINARY32_EXCESS));
      if(exponent > BINARY32_MAX_EXPONENT+BINARY32_EXCESS){
        if(significand.sign==PLUS){
          addToOutput("+Inf");
          return POS_INF;
        }else{
          addToOutput("-Inf");
          return NEG_INF;
        }
      } else if(exponent <= 0){
        significand.fraction = createZeroString(-exponent-1) + significand.whole + significand.fraction;
        significand.whole = "0";
        addToOutput("<br>");
        addToOutput("subnormalan broj: " + significand.toSigned());
      }
      addToOutput("<br>");

      addToOutput("znak: " + (significand.sign==PLUS?"0":"1") + "<br>");

      significand = fractionToLength(significand, BINARY32_SIGNIFICAND_LENGTH, false);
      exponent = toLength(fromDecimal(trimSign(toUOARNumber(exponent.toString(), 10 , NumberTypes.UNSIGNED, log)), 2, true, log), BINARY32_EXPONENT_LENGTH, 0, log).toUnsigned();

      var res = new IEEE754Number(significand.sign==PLUS?"0":"1", exponent, significand.fraction, IEEE754Formats.BINARY32);
      addToOutput(res.toString());
      return res;
    }

    function multiplyIEEE754(log=true){
      if(operand1==null || operand2==null || operand1.format!=IEEE754Formats.BINARY32 || operand2.format!=IEEE754Formats.BINARY32 || !isValidIEEE754(operand1) || !isValidIEEE754(operand2)){
        addToStackTrace("multiplyIEEE754", "Invalid operands", log);
        return null;
      }

      var special1 = getSpecialValueBinary32(operand1);
      var special2 = getSpecialValueBinary32(operand2);
      if(special1!=null || special2!=null){
        if(special1==QNAN || special2==QNAN){
          addToOutput("x * "+QNAN.toString()+" = "+QNAN.toString());
          return BINARY32_QNAN;
        } else if(special1==SNAN || special2==SNAN){
          addToOutput("x * "+SNAN.toString()+" = "+QNAN.toString());
          return BINARY32_QNAN;
        }else if(((special1==POS_ZERO || special1==NEG_ZERO) && (special2==POS_INF || special2==NEG_INF)) ||
                ((special1==POS_ZERO || special1==NEG_ZERO) && (special2==POS_INF || special2==NEG_INF))){
          addToOutput(POS_ZERO.toString()+" * "+POS_INF.toString()+" = "+QNAN.toString());
          return BINARY32_QNAN;
        }else if(special1==POS_ZERO || special2==POS_ZERO || special1==NEG_ZERO || special2==NEG_ZERO){
          addToOutput("x * "+POS_ZERO.toString()+"/"+NEG_ZERO.toString()+" = "+POS_ZERO.toString()+"/"+NEG_ZERO.toString());
          return operand1.sign==operand2.sign? BINARY_POS_ZERO : BINARY_NEG_ZERO;
        }else if((special1==POS_INF && special2==NEG_INF) || (special1==NEG_INF && special2==POS_INF)){
          addToOutput(POS_INF.toString()+" * "+NEG_INF.toString()+" = "+NEG_INF.toString());
          return BINARY32_NEG_INF;
        }else if(special1==POS_INF || special2==POS_INF){
          addToOutput("x * "+POS_INF.toString()+" = "+POS_INF.toString());
          return BINARY32_POS_INF;
        }else if(special1==NEG_INF || special2==NEG_INF){
          addToOutput("x * "+NEG_INF.toString()+" = "+NEG_INF.toString());
          return BINARY32_NEG_INF;
        }
      }

      var sign = operand1.sign==operand2.sign ? "0" : "1";
      addToOutput("znak: " + sign + "<br>");

      var exponent1 = baseToDecimalInteger(operand1.exponent, 2, NumberTypes.UNSIGNED, false);
      var exponent2 = baseToDecimalInteger(operand2.exponent, 2, NumberTypes.UNSIGNED, false);
      var exponent = exponent1 + exponent2 - BINARY32_EXCESS;
      addToOutput("eksp: " + exponent + " = " + BINARY32_EXCESS + " + " + (exponent-BINARY32_EXCESS) + "<br>");

      var significand1 = trimNumber(new UOARNumber("", (exponent1==0?"0":"1"), operand1.significand, 2, NumberTypes.UNSIGNED));
      var significand2 = trimNumber(new UOARNumber("", (exponent1==0?"0":"1"), operand2.significand, 2, NumberTypes.UNSIGNED));
      
      var multiplicand1 = new UOARNumber("", significand1.whole + significand1.fraction, "", 2, NumberTypes.UNSIGNED);
      var multiplicand2 = new UOARNumber("", significand2.whole + significand2.fraction, "", 2, NumberTypes.UNSIGNED);
      var significand = new UOARNumber("", "0", "", 2, NumberTypes.UNSIGNED);

      for(let i=multiplicand2.whole.length-1; i>=0; i--){
        if(multiplicand2.whole[i]=="1"){
          significand = add(significand, multiplicand1, NumberTypes.UNSIGNED, false);
        }
        multiplicand1.whole = multiplicand1.whole.concat("0");
      }
      let significand_fraction_len = significand1.fraction.length+significand2.fraction.length;
      significand.fraction = significand.whole.substr(significand.whole.length-significand_fraction_len);
      significand.whole = significand.whole.substr(0, significand.whole.length-significand_fraction_len);
      addToOutput("frakc: " + significand1.toUnsigned() + " * " + significand2.toUnsigned() + " = " + significand.toUnsigned() + "<br>");

      addToOutput("(" + significand.toSigned() + ")2 * 2^" + (exponent-BINARY32_EXCESS));
      var normalize_exponent = normalizeBinary(significand, true, false);
      exponent += normalize_exponent;
      if(normalize_exponent!=0)
        addToOutput(" = (" + significand.toSigned() + ")2 * 2^" + (exponent-BINARY32_EXCESS));
      if(exponent > BINARY32_MAX_EXPONENT+BINARY32_EXCESS){
        if(significand.sign==PLUS){
          addToOutput("+Inf");
          return POS_INF;
        }else{
          addToOutput("-Inf");
          return NEG_INF;
        }
      } else if(exponent <= 0){
        significand.fraction = createZeroString(-exponent-1) + significand.whole + significand.fraction;
        significand.whole = "0";
        addToOutput("<br>");
        addToOutput("subnormalan broj: " + significand.toSigned());
      }
      addToOutput("<br>");

      significand = fractionToLength(significand, BINARY32_SIGNIFICAND_LENGTH, false);
      exponent = toLength(fromDecimal(trimSign(toUOARNumber(exponent.toString(), 10 , NumberTypes.UNSIGNED, log)), 2, true, log), BINARY32_EXPONENT_LENGTH, 0, log).toUnsigned();

      var res = new IEEE754Number(sign, exponent, significand.fraction, IEEE754Formats.BINARY32);
      addToOutput(res.toString());
      return res;
    }

    function divideIEEE754(log=true){
      if(operand1==null || operand2==null || operand1.format!=IEEE754Formats.BINARY32 || operand2.format!=IEEE754Formats.BINARY32 || !isValidIEEE754(operand1) || !isValidIEEE754(operand2)){
        addToStackTrace("divideIEEE754", "Invalid operands", log);
        return null;
      }

      var special1 = getSpecialValueBinary32(operand1);
      var special2 = getSpecialValueBinary32(operand2);
      if(special1!=null || special2!=null){
        if(special1==QNAN || special2==QNAN){
          addToOutput("x / "+QNAN.toString()+" = "+QNAN.toString());
          return BINARY32_QNAN;
        } else if(special1==SNAN || special2==SNAN){
          addToOutput("x / "+SNAN.toString()+" = "+QNAN.toString());
          return BINARY32_QNAN;
        }else if((special1==POS_ZERO || special1==NEG_ZERO) && (special2==POS_ZERO || special2==NEG_ZERO)){
          addToOutput(POS_ZERO.toString()+"/"+NEG_ZERO.toString()+" / "+POS_ZERO.toString()+"/"+NEG_ZERO.toString()+" = "+POS_ZERO.toString()+"/"+NEG_ZERO.toString());
          return BINARY32_QNAN;
        }else if((special1==POS_INF || special1==NEG_INF) && (special2==POS_INF || special2==NEG_INF)){
          addToOutput(POS_INF.toString()+"/"+NEG_INF.toString()+" / "+POS_INF.toString()+"/"+NEG_INF.toString()+" = "+POS_INF.toString()+"/"+NEG_INF.toString());
          return BINARY32_QNAN;
        }else if(special2==POS_INF || special2==NEG_INF){
          addToOutput("x / "+POS_INF.toString()+"/"+NEG_INF.toString()+" = "+POS_INF.toString()+"/"+NEG_INF.toString());
          return operand1.sign==operand2.sign? BINARY_POS_ZERO : BINARY_NEG_ZERO;
        }else if(special2==POS_ZERO || special2==NEG_ZERO){
          addToOutput("x / "+POS_ZERO.toString()+"/"+NEG_ZERO.toString()+" = "+POS_ZERO.toString()+"/"+NEG_ZERO.toString());
          return operand1.sign==operand2.sign? BINARY_POS_INF : BINARY_NEG_INF;
        }
      }

      var sign = operand1.sign==operand2.sign ? "0" : "1";
      addToOutput("znak: " + sign + "<br>");

      var exponent1 = baseToDecimalInteger(operand1.exponent, 2, NumberTypes.UNSIGNED, false);
      var exponent2 = baseToDecimalInteger(operand2.exponent, 2, NumberTypes.UNSIGNED, false);
      var exponent = exponent1 - exponent2 + BINARY32_EXCESS;
      addToOutput("eksp: " + exponent + " = " + BINARY32_EXCESS + " + " + (exponent-BINARY32_EXCESS) + "<br>");

      var significand1 = trimNumber(new UOARNumber("", (exponent1==0?"0":"1"), operand1.significand, 2, NumberTypes.UNSIGNED));
      var significand2 = trimNumber(new UOARNumber("", (exponent1==0?"0":"1"), operand2.significand, 2, NumberTypes.UNSIGNED));
      if(significand2.fraction.length > significand1.fraction.length){
        fractionToLength(significand1, significand2.fraction.length, false);
      }
      significand1.whole = significand1.whole + significand1.fraction.substr(0, significand2.fraction.length);
      significand1.fraction = significand1.fraction.substr(significand2.fraction.length);
      significand2.whole = significand2.whole + significand2.fraction;
      significand2.fraction = "";

      var i = significand2.whole.length;
      var dividend_string = significand1.whole + significand1.fraction + "0";
      var dividend = new UOARNumber("+", dividend_string.substr(0, i), "", 2, NumberTypes.SIGNED);
      var divider = new UOARNumber("+", significand2.whole, "", 2, NumberTypes.SIGNED);
      var neg_divider = new UOARNumber("-", significand2.whole, "", 2, NumberTypes.SIGNED);
      var significand = new UOARNumber("+", "", "", 2, NumberTypes.SIGNED);
      for(; i<dividend_string.length; i++){
        if(isGreater(dividend, divider, true, false) || dividend.whole==divider.whole){
          dividend = add(dividend, neg_divider, NumberTypes.SIGNED, false);
          significand.whole = significand.whole.concat("1");
        }else{
          significand.whole = significand.whole.concat("0");
        }
        dividend.whole = dividend.whole + dividend_string[i];
      }
      significand.fraction = significand.whole.substr(significand1.whole.length-divider.whole.length+1);
      significand.whole = significand.whole.substr(0, significand1.whole.length-divider.whole.length+1);
      trimNumber(dividend);
      while(significand.whole.length+significand.fraction.length <= BINARY32_SIGNIFICAND_LENGTH+1 && dividend.whole!="0"){
        if(isGreater(dividend, divider, true, false) || dividend.whole==divider.whole){
          dividend = add(dividend, neg_divider, NumberTypes.SIGNED, false);
          significand.fraction = significand.fraction.concat("1");
        }else{
          significand.fraction = significand.fraction.concat("0");
        }
        dividend.whole = dividend.whole + "0";
      }
      trimNumber(significand);
      addToOutput("frakc: " + significand1.toUnsigned() + " / " + significand2.toUnsigned() + " = " + significand.toUnsigned() + "<br>");

      addToOutput("(" + significand.toSigned() + ")2 * 2^" + (exponent-BINARY32_EXCESS));
      var normalize_exponent = normalizeBinary(significand, true, false);
      exponent += normalize_exponent;
      if(normalize_exponent!=0)
        addToOutput(" = (" + significand.toSigned() + ")2 * 2^" + (exponent-BINARY32_EXCESS));
      if(exponent > BINARY32_MAX_EXPONENT+BINARY32_EXCESS){
        if(significand.sign==PLUS){
          addToOutput("+Inf");
          return POS_INF;
        }else{
          addToOutput("-Inf");
          return NEG_INF;
        }
      } else if(exponent <= 0){
        significand.fraction = createZeroString(-exponent-1) + significand.whole + significand.fraction;
        significand.whole = "0";
        addToOutput("<br>");
        addToOutput("subnormalan broj: " + significand.toSigned());
      }
      addToOutput("<br>");

      significand = fractionToLength(significand, BINARY32_SIGNIFICAND_LENGTH, false);
      exponent = toLength(fromDecimal(trimSign(toUOARNumber(exponent.toString(), 10 , NumberTypes.UNSIGNED, log)), 2, true, log), BINARY32_EXPONENT_LENGTH, 0, log).toUnsigned();

      var res = new IEEE754Number(sign, exponent, significand.fraction, IEEE754Formats.BINARY32);
      addToOutput(res.toString());
      return res;
    }
  </script>
</head>
<body>

  <div class="titlebar">
    <h1 class="title">IEEE754 Konverter</h1>
    <a class="back" href="../index.html"><img src="../images/back.svg" alt="Back"></a>
  </div>

  <div class="info">
    <p>
      IEEE754 Konverter pretvara dati broj u skladu sa standardom za zapis brojeva sa pokretnim zarezom IEEE754 i obratno.
      Podrzani formati zapisa su binary32, binary64, decimal32 DPD, decimal32 BID i hexadecimal 32.
      Osim konverzije moguce je vrsiti i osnovne racunske operacije nad brojevima zapisanim u formatu binary32.
    </p>
  </div>

  <div class="container center" id="main1">
    <table>
      <tr>
        <td><label for="input_significand">Znacajan deo:</label></td>
        <td><input type="text" id="input_significand"></input></td>
      </tr>
      <tr>
        <td><label for="input_exponent">Eksponent:</label></td>
        <td><input type="text" id="input_exponent"></input></td>
      </tr>
    </table>
    <input value="U binary32" type="button" name="toBinary32" id="toBinary32" class="button" onclick="convertToIEEE754(IEEE754Formats.BINARY32)"></input>
    <input value="U binary64" type="button" name="toBinary64" id="toBinary64" class="button" onclick="convertToIEEE754(IEEE754Formats.BINARY64)"></input>
    <input value="U decimal32 DPD" type="button" name="toDecimal32DPD" id="toDecimal32DPD" class="button" onclick="convertToIEEE754(IEEE754Formats.DECIMAL32DPD)"></input>
    <input value="U decimal32 BID" type="button" name="toDecimal32BID" id="toDecimal32BID" class="button" onclick="convertToIEEE754(IEEE754Formats.DECIMAL32BID)"></input>
    <input value="U hexadecimal32" type="button" name="toHexadecimal32" id="toHexadecimal32" class="button" onclick="convertToIEEE754(IEEE754Formats.HEXADECIMAL32)"></input>
  
    <div class="solution hidden" id="solution1"></div>
  </div>

  <div class="container center" id="main2">
    <table>
      <tr>
        <td><label for="input_significand">IEEE754 broj:</label></td>
        <td><input type="text" id="input_ieee754"></input></td>
      </tr>
    </table>
    <input value="Iz binary32" type="button" name="fromBinary32" id="fromBinary32" class="button" onclick="convertFromIEEE754(IEEE754Formats.BINARY32)"></input>
    <input value="Iz binary64" type="button" name="fromBinary64" id="fromBinary64" class="button" onclick="convertFromIEEE754(IEEE754Formats.BINARY64)"></input>
    <input value="Iz decimal32 DPD" type="button" name="fromDecimal32DPD" id="fromDecimal32DPD" class="button" onclick="convertFromIEEE754(IEEE754Formats.DECIMAL32DPD)"></input>
    <input value="Iz decimal32 BID" type="button" name="fromDecimal32BID" id="fromDecimal32BID" class="button" onclick="convertFromIEEE754(IEEE754Formats.DECIMAL32BID)"></input>
    <input value="Iz hexadecimal32" type="button" name="fromHexadecimal32" id="fromHexadecimal32" class="button" onclick="convertFromIEEE754(IEEE754Formats.HEXADECIMAL32)"></input>

    <div class="solution hidden" id="solution2"></div>
  </div>

  <div class="container center" id="main3">
    <table>
      <tr>
        <td><label for="input_operand1">1. operand:</label></td>
        <td><input type="text" id="input_operand1"></input></td>
      </tr>
      <tr>
        <td><label for="input_operand2">2. operand:</label></td>
        <td><input type="text" id="input_operand2"></input></td>
      </tr>
    </table>
    <input value="Saberi" type="button" name="addIEEE754" id="addIEEE754" class="button" onclick="doOperation(ArithmeticOperations.ADDITION)"></input>
    <input value="Oduzmi" type="button" name="subtractIEEE754" id="subtractIEEE754" class="button" onclick="doOperation(ArithmeticOperations.SUBTRACTION)"></input>
    <input value="Pomnozi" type="button" name="multiplyIEEE754" id="multiplyIEEE754" class="button" onclick="doOperation(ArithmeticOperations.MULTIPLICATION)"></input>
    <input value="Podeli" type="button" name="divideIEEE754" id="divideIEEE754" class="button" onclick="doOperation(ArithmeticOperations.DIVISION)"></input>

    <div class="solution hidden" id="solution3"></div>
  </div>

</body>
</html>
