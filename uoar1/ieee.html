<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>IEEE Konverter</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script type="text/javascript" src="uoar_core.js"></script>
  <script type="text/javascript" src="output.js"></script>
  <script type="text/javascript" src="ieee754.js"></script>
  <script>

    function convertToIEEE754(format){
      var significand = toUOARNumber(document.getElementById('significand').value, 10, NumberTypes.SIGNED, false);
      var exponent = document.getElementById('exponent').value;
      clearStackTrace();
      clearOutput();
      var res;
      switch(format){
        case IEEE754Formats.BINARY32:
          res = convertToIEEE754Binary32(significand, exponent);
          break;
        case IEEE754Formats.BINARY64:
          res = convertToIEEE754Binary64(significand, exponent);
          break;
        case IEEE754Formats.DECIMAL32DPD:
          res = convertToIEEE754Decimal32DPD(significand, exponent);
          break;
        case IEEE754Formats.DECIMAL32BID:
          res = convertToIEEE754Decimal32BID(significand, exponent);
          break;
        case IEEE754Formats.HEXADECIMAL32:
          res = convertToIEEE754Hexadecimal32(significand, exponent);
          break;
      }
      if(res!=null){
        document.getElementById("text1").innerHTML=output;
      }
    }

    function convertToIEEE754Binary32(significand, exponent, standardized=false, log=true){
      if(significand.number_type!=NumberTypes.SIGNED){
        addToStackTrace("convertToIEEE754Binary32", "Significand isn't signed", log);
        return null;
      }
      if(!standardized){
        significand = standardizeUOARNumber(significand.copy(), false);
        if(significand===null){
          addToStackTrace("convertToIEEE754Binary32", "Invalid significand \"" + significand.toSigned() + "\"", log);
          return null;
        }
      }
      var work1 = "";
      var work2 = "";
      work1 = work1.concat(significand.sign + "(" + significand.toUnsigned() + ")10");
      significand = fromDecimal(significand, 2, true, false);
      work2 = work2.concat(significand.sign + "(" + significand.toUnsigned() + ")2");
      if(significand.whole.length>BINARY32_SIGNIFICAND_LENGTH){
        let res;
        if(significand.sign==PLUS)
          res = new IEEE754Number("0", "11111111", "00000000000000000000000");
        else
          res = new IEEE754Number("1", "11111111", "00000000000000000000000");
        addToOutput(res.toString());
        return res;
      }
      exponent = baseToDecimalInteger(exponent, 10, NumberTypes.SIGNED, false, log);
      if(exponent===null){
        addToStackTrace("convertToIEEE754Binary32", "Invalid exponent \"" + exponent + "\" for base 10", log);
        return null;
      }
      work1 = work1.concat(" * 2^" + exponent);
      work2 = work2.concat(" * 2^" + exponent);

      var normalize_exponent = normalizeBinary(significand, true, log);
      exponent = exponent + normalize_exponent;
      if(!isInBounds(exponent, BINARY32_MIN_EXPONENT, BINARY32_MAX_EXPONENT)){
        addToStackTrace("convertToIEEE754Binary32", "Exponent out of bounds \"" + exponent + "\"", log);
        return null;
      }
      addToOutput(work1 + " = ");
      addToOutput(work2 + " = ");
      addToOutput(significand.sign + "(" + significand.toUnsigned() + ")2 * 2^" + exponent + "<br>");
      significand = fractionToLength(significand, BINARY32_SIGNIFICAND_LENGTH-significand.whole.length, log);

      var res_sign = significand.sign==PLUS ? "0" : "1";
      var res_exponent = toLength(fromDecimal(trimSign(toUOARNumber((BINARY32_EXCESS+exponent).toString(), 10 , NumberTypes.SIGNED, log)), 2, true, log), BINARY32_EXPONENT_LENGTH, 0, log).toUnsigned();
      addToOutput("eksp: " + exponent.toString() + " + " + BINARY32_EXCESS.toString() + " = " + (BINARY32_EXCESS+exponent) + " = (" + res_exponent + ")2 <br>");
      var res_significand = fractionToLength(significand, BINARY32_SIGNIFICAND_LENGTH, log).fraction;
      var res = new IEEE754Number(res_sign, res_exponent, res_significand, IEEE754Formats.BINARY32);
      addToOutput(res.toString());
      return res;
    }

    function convertToIEEE754Binary64(significand, exponent, standardized=false, log=true){
      if(significand.number_type!=NumberTypes.SIGNED){
        addToStackTrace("convertToIEEE754Binary64", "Significand isn't signed", log);
        return null;
      }
      if(!standardized){
        significand = standardizeUOARNumber(significand.copy(), false);
        if(significand===null){
          addToStackTrace("convertToIEEE754Binary64", "Invalid significand \"" + significand.toSigned() + "\"", log);
          return null;
        }
      }
      var work1 = "";
      var work2 = "";
      work1 = work1.concat(significand.sign + "(" + significand.toUnsigned() + ")10");
      significand = fromDecimal(significand, 2, true, false);
      work2 = work2.concat(significand.sign + "(" + significand.toUnsigned() + ")2");
      if(significand.whole.length>BINARY64_SIGNIFICAND_LENGTH){
        if(significand.sign==PLUS)
          return new IEEE754Number("0", "11111111111", "0000000000000000000000000000000000000000000000000000");
        else
          return new IEEE754Number("1", "11111111111", "0000000000000000000000000000000000000000000000000000");
      }
      exponent = baseToDecimalInteger(exponent, 10, NumberTypes.SIGNED, false, log);
      if(exponent===null){
        addToStackTrace("convertToIEEE754Binary64", "Invalid number \"" + exponent + "\" for base 10", log);
        return null;
      }
      work1 = work1.concat(" * 2^" + exponent);
      work2 = work2.concat(" * 2^" + exponent);

      var normalize_exponent = normalizeBinary(significand, true, log);
      exponent = exponent + normalize_exponent; 
      if(!isInBounds(exponent, BINARY64_MIN_EXPONENT, BINARY64_MAX_EXPONENT)){
        addToStackTrace("convertToIEEE754Binary64", "Exponent out of bounds \"" + exponent + "\"", log);
        return null;
      }
      addToOutput(work1 + " = ");
      addToOutput(work2 + " = ");
      addToOutput(significand.sign + "(" + significand.toUnsigned() + ")2 * 2^" + exponent + "<br>");
      significand = fractionToLength(significand, BINARY64_SIGNIFICAND_LENGTH-significand.whole.length, log);

      var res_sign = significand.sign==PLUS ? "0" : "1";
      var res_exponent = toLength(fromDecimal(trimSign(toUOARNumber((BINARY64_EXCESS+exponent).toString(), 10 , NumberTypes.SIGNED, log)), 2, true, log), BINARY64_EXPONENT_LENGTH, 0, log).toUnsigned();
      addToOutput("eksp: " + exponent.toString() + " + " + BINARY64_EXCESS.toString() + " = " + (BINARY64_EXCESS+exponent) + " = (" + res_exponent + ")2 <br>");
      var res_significand = fractionToLength(significand, BINARY64_SIGNIFICAND_LENGTH, log).fraction;
      var res = new IEEE754Number(res_sign, res_exponent, res_significand, IEEE754Formats.BINARY64);
      addToOutput(res.toString());
      return res;
    }

    function convertToIEEE754Decimal32DPD(significand, exponent, standardized=false, log=true){
      if(significand.number_type!=NumberTypes.SIGNED){
        addToStackTrace("convertToIEEE754Decimal32DPD", "Significand isn't signed", log);
        return null;
      }
      if(!standardized){
        significand = standardizeUOARNumber(significand.copy(), false);
        if(significand===null){
          addToStackTrace("convertToIEEE754Decimal32DPD", "Invalid significand \"" + significand.toSigned() + "\"", log);
          return null;
        }
      }
      if(significand.whole.length>DECIMAL32_SIGNIFICAND_LENGTH){
        if(significand.sign==PLUS)
          return new IEEE754Number("0", "11110000000", "00000000000000000000");
        else
          return new IEEE754Number("1", "11110000000", "00000000000000000000");
      }
      exponent = baseToDecimalInteger(exponent, 10, NumberTypes.SIGNED, false, log);
      if(exponent===null){
        addToStackTrace("convertToIEEE754Decimal32DPD", "Invalid number \"" + exponent + "\" for base 10", log);
        return null;
      }
      var work1 = significand.sign + "(" + significand.toUnsigned() + ")10 * 10^" + exponent;

      var normalize_exponent = normalizeDecimal(significand, true, log);
      exponent = exponent + normalize_exponent; 
      if(!isInBounds(exponent, DECIMAL32_MIN_EXPONENT, DECIMAL32_MAX_EXPONENT)){
        addToStackTrace("convertToIEEE754Decimal32DPD", "Exponent out of bounds \"" + exponent + "\"", log);
        return null;
      }

      significand = wholeToLength(significand, DECIMAL32_DIGITS, log);
      if(significand===null){
        addToStackTrace("convertToIEEE754Decimal32DPD", "Significand out of bounds \"" + significand.toSigned() + "\"", log);
        return null;
      }
      addToOutput(work1 + " = ");
      addToOutput(significand.sign + "(" + significand.toUnsigned() + ")10 * 10^" + exponent + "<br>");

      var res_sign = significand.sign==PLUS ? "0" : "1";
      var res_exponent;
      var na = addZeroesBefore(digitToBinary(significand.whole, 0), 10, NumberTypes.UNSIGNED, 4, log);
      var nb = wholeToLength(fromDecimal(trimSign(toUOARNumber((DECIMAL32_EXCESS+exponent).toString(), 10, NumberTypes.SIGNED, log)), 2, true, log), 8, log).toUnsigned();
      addToOutput("eksp: " + exponent.toString() + " + " + DECIMAL32_EXCESS.toString() + " = " + (DECIMAL32_EXCESS+exponent) + " = (" + nb + ")2 <br>");
      if(na.charAt(0)=='0'){
        addToOutput("komb: " + nb.substr(0,2) + " " + na.substr(1,3) + " " + nb.substr(2,6) + "<br>");
        res_exponent = nb.substr(0,2)+na.substr(1,3)+nb.substr(2,6);
      }else{
        addToOutput("komb: 11 " + nb.substr(0, 2) + na.charAt(3) + " " +nb.substr(2, 6));
        res_exponent = "11"+nb.substr(0, 2)+na.charAt(3)+nb.substr(2, 6);
      }
      var res_significand;
      addToOutput("<table>");
      addToOutput("<tr>");
      for(let i=1; i<=6; i++){
        addToOutput("<td>" + significand.whole.charAt(i) + "</td>");
      }
      addToOutput("</tr>");
      addToOutput("<tr>");
      for(let i=1; i<=6; i++){
        addToOutput("<td>" + addZeroesBefore(numberToBinary(significand.whole.charAt(i), log), 2, NumberTypes.UNSIGNED, 4, log) + "</td>");
      }
      addToOutput("</tr>");
      var nc1 = decimalToDPD(decimalTo8421(significand.whole.substr(1, 3)));
      var nc2 = decimalToDPD(decimalTo8421(significand.whole.substr(4, 3)));
      addToOutput("<tr><td colspan=\"3\">" + nc1 + "</td><td colspan=\"3\">" + nc2 + "</td></tr>");
      addToOutput("</table><br>");
      res_significand = nc1 + nc2;
      var res = new IEEE754Number(res_sign, res_exponent, res_significand, IEEE754Formats.DECIMAL32DPD);
      addToOutput(res);
      return res;
    }

    function convertToIEEE754Decimal32BID(significand, exponent, standardized=false, log=true){
      if(significand.number_type!=NumberTypes.SIGNED){
        addToStackTrace("convertToIEEE754Decimal32BID", "Significand isn't signed", log);
        return null;
      }
      if(!standardized){
        significand = standardizeUOARNumber(significand.copy(), false);
        if(significand===null){
          addToStackTrace("convertToIEEE754Decimal32BID", "Invalid significand \"" + significand.toSigned() + "\"", log);
          return null;
        }
      }
      if(significand.whole.length>DECIMAL32_SIGNIFICAND_LENGTH){
        if(significand.sign==PLUS)
          return new IEEE754Number("0", "11110000000", "00000000000000000000");
        else
          return new IEEE754Number("1", "11110000000", "00000000000000000000");
      }
      exponent = baseToDecimalInteger(exponent, 10, NumberTypes.SIGNED, false, log);
      if(exponent===null){
        addToStackTrace("convertToIEEE754Decimal32BID", "Invalid number \"" + exponent + "\" for base 10", log);
        return null;
      }
      var work1 = significand.sign + "(" + significand.toUnsigned() + ")10 * 10^" + exponent;

      var normalize_exponent = normalizeDecimal(significand, true, log);
      exponent = exponent + normalize_exponent; 
      if(!isInBounds(exponent, DECIMAL32_MIN_EXPONENT, DECIMAL32_MAX_EXPONENT)){
        addToStackTrace("convertToIEEE754Decimal32BID", "Exponent out of bounds \"" + exponent + "\"", log);
        return null;
      }
      addToOutput(work1 + " = ");
      addToOutput(significand.sign+ "(" + significand.toUnsigned() + ")10 * 10^" + exponent + " = ");

      significand = wholeToLength(fromDecimal(significand, 2, true, log), 1+BINARY32_SIGNIFICAND_LENGTH, log);
      if(significand===null){
        addToStackTrace("convertToIEEE754Decimal32BID", "Significand out of bounds \"" + significand.toSigned() + "\"", log);
        return null;
      }
      addToOutput(significand.sign + "(" + significand.toUnsigned() + ")2 * 10^" + exponent + "<br>");

      var res_sign = significand.sign==PLUS ? "0" : "1";
      var res_exponent;
      var na = significand.whole.substr(0,4);
      var nb = wholeToLength(fromDecimal(trimSign(toUOARNumber((DECIMAL32_EXCESS+exponent).toString(), 10, NumberTypes.SIGNED, log)), 2, true, log), 8, log).toUnsigned();
      addToOutput("eksp: " + exponent.toString() + " + " + DECIMAL32_EXCESS.toString() + " = " + (DECIMAL32_EXCESS+exponent) + " = (" + nb + ")2 <br>");
      if(na.charAt(0)=='0'){
        addToOutput("komb: " + nb + " " + na.substr(1,3) + "<br>");
        res_exponent = nb+na.substr(1,3);
      }else{
        addToOutput("komb: 11 " + nb + " " + na.charAt(3));
        res_exponent = "11"+nb+na.charAt(3);
      }
      var res_significand = significand.whole.substr(4);
      var res = new IEEE754Number(res_sign, res_exponent, res_significand, IEEE754Formats.DECIMAL32BID);
      addToOutput(res);
      return res;
    }

    function convertToIEEE754Hexadecimal32(significand, exponent, standardized=false, log=true){
      if(significand.number_type!=NumberTypes.SIGNED){
        addToStackTrace("convertToIEEE754Hexadecimal32", "Significand isn't signed", log);
        return null;
      }
      if(!standardized){
        significand = standardizeUOARNumber(significand.copy(), false);
        if(significand===null){
          addToStackTrace("convertToIEEE754Hexadecimal32", "Invalid significand \"" + significand.toSigned() + "\"", log);
          return null;
        }
      }
      if(significand.whole.length>HEXADECIMAL32_SIGNIFICAND_LENGTH){
        if(significand.sign==PLUS)
          return new IEEE754Number("0", "11111111", "00000000000000000000000");
        else
          return new IEEE754Number("1", "11111111", "00000000000000000000000");
      }
      var work1 = "";
      var work2 = "";
      work1 = work1.concat(significand.sign + "(" + significand.toUnsigned() + ")10");
      significand = fromDecimal(significand, 16, true, log);
      work2 = work2.concat(significand.sign + "(" + significand.toUnsigned() + ")16");
      exponent = baseToDecimalInteger(exponent, 10, NumberTypes.SIGNED, false, log);
      if(exponent===null){
        addToStackTrace("convertToIEEE754Hexadecimal32", "Invalid number \"" + exponent + "\" for base 10", log);
        return null;
      }
      work1 = work1.concat(" * 16^" + exponent);
      work2 = work2.concat(" * 16^" + exponent);

      var normalize_exponent = normalizeHexadecimal(significand, true, log);
      exponent = exponent + normalize_exponent; 
      if(!isInBounds(exponent, HEXADECIMAL32_MIN_EXPONENT, HEXADECIMAL32_MAX_EXPONENT)){
        addToStackTrace("convertToIEEE754Hexadecimal32", "Exponent out of bounds \"" + exponent + "\"", log);
        return null;
      }
      addToOutput(work1 + " = ");
      addToOutput(work2 + " = ");
      addToOutput(significand.sign + "(" + significand.toUnsigned() + ")16 * 16^" + exponent + "<br>");

      var res_sign = significand.sign==PLUS ? "0" : "1";
      var res_exponent = toLength(fromDecimal(trimSign(toUOARNumber((HEXADECIMAL32_EXCESS+exponent).toString(), 10, NumberTypes.SIGNED, log)), 2, true, log), HEXADECIMAL32_EXPONENT_LENGTH, 0, log).toUnsigned();
      addToOutput("eksp: " + exponent.toString() + " + " + HEXADECIMAL32_EXCESS + " = " + (HEXADECIMAL32_EXCESS+exponent) + " = (" + res_exponent + ")2 <br>");
      var res_significand = decimalTo8421(significand.fraction);
      var res = new IEEE754Number(res_sign, res_exponent, res_significand, IEEE754Formats.HEXADECIMAL32);
      addToOutput(res);
      return res;
    }

    function convertFromIEEE754(format){
      var ieee = document.getElementById('ieee').value.toString();
      clearStackTrace();
      clearOutput();
      var res;
      switch(format){
        case IEEE754Formats.BINARY32:
          res = convertFromIEEE754Binary32(toIEEE754Number(ieee, IEEE754Formats.BINARY32));
          break;
        case IEEE754Formats.BINARY64:
          res = convertFromIEEE754Binary64(toIEEE754Number(ieee, IEEE754Formats.BINARY64));
          break;
        case IEEE754Formats.DECIMAL32DPD:
          res = convertFromIEEE754Decimal32DPD(toIEEE754Number(ieee, IEEE754Formats.DECIMAL32DPD));
          break;
        case IEEE754Formats.DECIMAL32BID:
          res = convertFromIEEE754Decimal32BID(toIEEE754Number(ieee, IEEE754Formats.DECIMAL32BID));
          break;
        case IEEE754Formats.HEXADECIMAL32:
          res = convertFromIEEE754Hexadecimal32(toIEEE754Number(ieee, IEEE754Formats.HEXADECIMAL32));
          break;
      }
      if(res!=null){
        document.getElementById("text2").innerHTML=output;
      }
    }

    function convertFromIEEE754Binary32(number, log=true){
      if(!isValidIEEE754(number, IEEE754Formats.BINARY32)){
        addToStackTrace("convertFromIEEE754Binary32", "Invalid IEEE754 Binary32 number \"" + number + "\"", log);
        return null;
      }

      var res = getSpecialValueBinary32(number);
      if(res!=null){
        addToOutput("specijalna vrednost: " + res.toString() + "<br>");
        return res;
      }

      var sign = number.sign=="0" ? PLUS : MINUS;
      var significand;
      var exponent = baseToDecimalInteger(number.exponent, 2, NumberTypes.UNSIGNED, log);
      addToOutput("eksp: (" + number.exponent + ")2 - " + BINARY32_EXCESS.toString() + " = " + exponent + " - " + BINARY32_EXCESS.toString() + " = ");
      exponent -= BINARY32_EXCESS;
      addToOutput(exponent + "<br>");

      if(exponent==-BINARY32_EXCESS){
        addToOutput("subnormalan broj<br>");
        significand = trimNumber(new UOARNumber(sign, "0", number.significand, 2, NumberTypes.SIGNED));
        addToOutput("(" + significand.toSigned() + ")2 * 2^" + (exponent+1) + " = ");
        exponent += 1+normalizeBinary(significand, true, log);
      }else{
        significand = trimNumber(new UOARNumber(sign, "1", number.significand, 2, NumberTypes.SIGNED));
        addToOutput("frakc: (" + significand.toSigned() + ")2<br>");
      }

      var whole = significand.whole!="0";
      var len = (whole? 1 : 0) + significand.fraction.length;
      if(len!=1){
        if(!whole)
          significand.whole="";
        if(exponent>=0 && exponent<10){
          significand.whole = significand.whole.concat(significand.fraction.substr(0, exponent));
          significand.fraction = significand.fraction.substr(exponent);
          exponent = 0;
        }else{
          if(len<9){
            exponent -= significand.fraction.length;
            significand.whole = significand.whole.concat(significand.fraction);
            significand.fraction = "";
          }else if(len<14){
            exponent -= 8-(whole? 1 : 0);
            significand.whole = significand.whole.concat(significand.fraction.substr(0, 8-(whole? 1 : 0)));
            significand.fraction = significand.fraction.substr(8-(whole? 1 : 0));
          }else{
            exponent -= len-5-(whole? 1 : 0);
            significand.whole = significand.whole.concat(significand.fraction.substr(0, len-5-(whole? 1 : 0)));
            significand.fraction = significand.fraction.substr(len-5-(whole? 1 : 0));
          }
        }
      }
      addToOutput("(" + significand.toSigned() + ")2 * 2^" + exponent + " = ");
      significand = toDecimal(significand, true, log);
      addToOutput("(" + significand.toSigned() + ")2 * 2^" + exponent + "<br>");
      return new SignificandExponentPair(significand, 2, exponent);
    }

    function convertFromIEEE754Binary64(number, log=true){
      if(!isValidIEEE754(number, IEEE754Formats.BINARY64)){
        addToStackTrace("convertFromIEEE754Binary64", "Invalid IEEE754 Binary64 number \"" + number + "\"", log);
        return null;
      }

      var res = getSpecialValueBinary64(number);
      if(res!=null){
        addToOutput("specijalna vrednost: " + res.toString() + "<br>");
        return res;
      }

      var sign = number.sign=="0" ? PLUS : MINUS;
      var significand;
      var exponent = baseToDecimalInteger(number.exponent, 2, NumberTypes.UNSIGNED, log);
      addToOutput("eksp: (" + number.exponent + ")2 - " + BINARY32_EXCESS.toString() + " = " + exponent + " - " + BINARY32_EXCESS.toString() + " = ");
      exponent -= BINARY64_EXCESS;
      addToOutput(exponent + "<br>");

      if(exponent==-BINARY64_EXCESS){
        addToOutput("subnormalan broj<br>");
        significand = trimNumber(new UOARNumber(sign, "0", number.significand, 2, NumberTypes.SIGNED));
        addToOutput("(" + significand.toSigned() + ")2 * 2^" + (exponent+1) + " = ");
        exponent += 1+normalizeBinary(significand, true, log);
      }else{
        significand = trimNumber(new UOARNumber(sign, "1", number.significand, 2, NumberTypes.SIGNED));
        addToOutput("frakc: (" + significand.toSigned() + ")2<br>");
      }

      var whole = significand.whole!="0";
      var len = (whole? 1 : 0) + significand.fraction.length;
      if(len!=1){
        if(!whole)
          significand.whole="";
        if(exponent>=0 && exponent<10){
          significand.whole = significand.whole.concat(significand.fraction.substr(0, exponent));
          significand.fraction = significand.fraction.substr(exponent);
          exponent = 0;
        }else{
          if(len<9){
            exponent -= significand.fraction.length;
            significand.whole = significand.whole.concat(significand.fraction);
            significand.fraction = "";
          }else if(len<14){
            exponent -= 8-(whole? 1 : 0);
            significand.whole = significand.whole.concat(significand.fraction.substr(0, 8-(whole? 1 : 0)));
            significand.fraction = significand.fraction.substr(8-(whole? 1 : 0));
          }else{
            exponent -= len-5-(whole? 1 : 0);
            significand.whole = significand.whole.concat(significand.fraction.substr(0, len-5-(whole? 1 : 0)));
            significand.fraction = significand.fraction.substr(len-5-(whole? 1 : 0));
          }
        }
      }
      addToOutput("(" + significand.toSigned() + ")2 * 2^" + exponent + " = ");
      significand = toDecimal(significand, true, log);
      addToOutput("(" + significand.toSigned() + ")2 * 2^" + exponent + "<br>");
      return new SignificandExponentPair(significand, 2, exponent);
    }

    function convertFromIEEE754Decimal32DPD(number, log=true){
      if(!isValidIEEE754(number, IEEE754Formats.DECIMAL32DPD)){
        addToStackTrace("convertFromIEEE754Decimal32DPD", "Invalid IEEE754 Decimal32 number \"" + number + "\"", log);
        return null;
      }

      var res = getSpecialValueDecimal32(number);
      if(res!=null){
        addToOutput("specijalna vrednost: " + res.toString() + "<br>");
        return res;
      }

      var sign = number.sign=="0" ? PLUS : MINUS;
      var significand;
      var comb = "";
      if(number.exponent.substr(0, 2)=="11"){
        significand = "100" + number.exponent.charAt(4);
        comb = number.exponent.substr(2, 2) + number.exponent.substr(5, 6);
      }else{
        significand = "0" + number.exponent.substr(2, 3);
        comb = number.exponent.substr(0,2) + number.exponent.substr(5, 6);
      }

      var exponent = baseToDecimalInteger(comb, 2, NumberTypes.UNSIGNED, log);
      if(exponent==0){
        addToOutput("subnormalan broj<br>");
        exponent = -DECIMAL32_EXCESS - DECIMAL32_DIGITS;
        addToOutput("eksp: " + exponent + "<br>");
      }else{
        addToOutput("eksp: (" + comb + ")2 - " + DECIMAL32_EXCESS + " = " + exponent + " - " + DECIMAL32_EXCESS + " = ");
        exponent -= DECIMAL32_EXCESS;
        addToOutput(exponent + "<br>");
      }

      let dpd1 = DPDtoDecimal(number.significand.substr(0, DECIMAL32_TRIPLET_LENGTH), log);
      let dpd2 = DPDtoDecimal(number.significand.substr(DECIMAL32_TRIPLET_LENGTH, DECIMAL32_TRIPLET_LENGTH), log);
      addToOutput("frakc: (" + significand + " " + dpd1 + " " + dpd2 + ")2 = ");
      significand = significand + dpd1 + dpd2;
      significand = trimNumber(new UOARNumber(sign, decimalFrom8421(significand, log), "", 10, NumberTypes.SIGNED));
      addToOutput("(" + significand.toUnsigned() + ")10 <br>");

      addToOutput("(" + significand.toSigned() + ")10 * 10^" + exponent);
      var normalize_exponent = normalizeDecimal(significand, true, log);
      if(normalize_exponent>0){
        exponent += normalize_exponent;
        addToOutput(" = (" + significand.toSigned() + ")10 * 10^" + exponent + "<br>");
      }

      return new SignificandExponentPair(significand, 10, exponent);
    }

    function convertFromIEEE754Decimal32BID(number, log=true){
      if(!isValidIEEE754(number, IEEE754Formats.DECIMAL32BID)){
        addToStackTrace("convertFromIEEE754Decimal32BID", "Invalid IEEE754 Decimal32 number \"" + number + "\"", log);
        return null;
      }

      var res = getSpecialValueDecimal32(number);
      if(res!=null){
        return res;
      }

      var sign = number.sign=="0" ? PLUS : MINUS;
      var significand;
      var comb = "";
      if(number.exponent.substr(0, 2)=="11"){
        significand = "100" + number.exponent.charAt(10);
        comb = number.exponent.substr(2, 8);
      }else{
        significand = "0" + number.exponent.substr(8, 3);
        comb = number.exponent.substr(0,8);
      }

      var exponent = baseToDecimalInteger(comb, 2, NumberTypes.UNSIGNED, log);
      if(exponent==0){
        addToOutput("subnormalan broj<br>");
        exponent = -DECIMAL32_EXCESS - DECIMAL32_DIGITS;
        addToOutput("eksp: " + exponent + "<br>");
      }else{
        addToOutput("eksp: (" + comb + ")2 - " + DECIMAL32_EXCESS + " = " + exponent + " - " + DECIMAL32_EXCESS + " = ");
        exponent -= DECIMAL32_EXCESS;
        addToOutput(exponent + "<br>");
      }

      addToOutput("frakc: (" + significand + " " + number.significand + ")2 = ");
      significand = significand + number.significand;
      significand = toDecimal(new UOARNumber(sign, significand, "", 2, NumberTypes.SIGNED), false, log);
      addToOutput("(" + significand.toUnsigned() + ")10 <br>");

      addToOutput("(" + significand.toSigned() + ")10 * 10^" + exponent);
      var normalize_exponent = normalizeDecimal(significand, true, log);
      if(normalize_exponent>0){
        exponent += normalize_exponent;
        addToOutput(" = (" + significand.toSigned() + ")10 * 10^" + exponent + "<br>");
      }

      return new SignificandExponentPair(significand, 10, exponent);
    }

    function convertFromIEEE754Hexadecimal32(number, log=true){
      if(!isValidIEEE754(number, IEEE754Formats.HEXADECIMAL32)){
        addToStackTrace("convertFromIEEE754Hexadecimal32", "Invalid IEEE754 Hexadecimal32 number \"" + number + "\"", log);
        return null;
      }

      var sign = number.sign=="0" ? PLUS : MINUS;
      var significand = trimNumber(new UOARNumber(sign, "0", decimalFrom8421(number.significand), 16, NumberTypes.SIGNED));
      var exponent = baseToDecimalInteger(number.exponent, 2, NumberTypes.UNSIGNED, log);
      addToOutput("eksp: (" + number.exponent + ")2 - " + HEXADECIMAL32_EXCESS.toString() + " = " + exponent + " - " + HEXADECIMAL32_EXCESS + " = ");
      exponent -= HEXADECIMAL32_EXCESS;
      addToOutput(exponent + "<br>");

      addToOutput("frakc: (0." + number.significand + ")2 = (" + significand.toUnsigned() + ")16 <br>");
      addToOutput("(" + significand.toUnsigned() + ")16 * 16^" + exponent + " = ");

      var len = significand.fraction.length;
      if(exponent>=0 && exponent<6){
        significand.whole = significand.fraction.substr(0, exponent);
        significand.fraction = significand.fraction.substr(exponent);
        exponent = 0;
      }else{
        if(len<6){
          exponent += significand.fraction.length;
          significand.whole = significand.fraction;
          significand.fraction = "";
        }else if(len<9){
          exponent -= 6;
          significand.whole = significand.fraction.substr(0, 6);
          significand.fraction = significand.fraction.substr(6);
        }else{
          exponent -= len-3;
          significand.whole = significand.fraction.substr(0, len-3);
          significand.fraction = significand.fraction.substr(len-3);
        }
      }
      addToOutput("(" + significand.toUnsigned() + ")16 * 16^" + exponent + " = ");
      significand = toDecimal(significand, false, log);
      addToOutput("(" + significand.toUnsigned() + ")10 * 16^" + exponent);
      return new SignificandExponentPair(significand, 16, exponent);
    }
  </script>
</head>
<body>

  <div class="container" id="main">
    <p>significand</p>
    <input type="text" id="significand"></input>
    <p>exponent</p>
    <input type="number" id="exponent"></input>
    <br><br>
    <input value="Izracunaj binary32" type="button" name="toBinary32" id="toBinary32" onclick="convertToIEEE754(IEEE754Formats.BINARY32)"></input>
    <input value="Izracunaj binary64" type="button" name="toBinary64" id="toBinary64" onclick="convertToIEEE754(IEEE754Formats.BINARY64)"></input>
    <input value="Izracunaj decimal32 DPD" type="button" name="toDecimal32DPD" id="toDecimal32DPD" onclick="convertToIEEE754(IEEE754Formats.DECIMAL32DPD)"></input>
    <input value="Izracunaj decimal32 BID" type="button" name="toDecimal32BID" id="toDecimal32BID" onclick="convertToIEEE754(IEEE754Formats.DECIMAL32BID)"></input>
    <input value="Izracunaj hexadecimal32" type="button" name="toHexadecimal32" id="toHexadecimal32" onclick="convertToIEEE754(IEEE754Formats.HEXADECIMAL32)"></input>

    <p id="text1">
      resenje
    </p>

    <hr>

    <input type="text" name="ieee" id="ieee"></input>
    <input type="button" name="fromBinary32" id="fromBinary32" value="From binary32" onclick="convertFromIEEE754(IEEE754Formats.BINARY32)"></input>
    <input type="button" name="fromBinary64" id="fromBinary64" value="From binary64" onclick="convertFromIEEE754(IEEE754Formats.BINARY64)"></input>
    <input type="button" name="fromDecimal32DPD" id="fromDecimal32DPD" value="From decimal32 DPD" onclick="convertFromIEEE754(IEEE754Formats.DECIMAL32DPD)"></input>
    <input type="button" name="fromDecimal32BID" id="fromDecimal32BID" value="From decimal32 BID" onclick="convertFromIEEE754(IEEE754Formats.DECIMAL32BID)"></input>
    <input type="button" name="fromHexadecimal32" id="fromHexadecimal32" value="From hexadecimal32" onclick="convertFromIEEE754(IEEE754Formats.HEXADECIMAL32)"></input>

    <p id="text2">
      resenje
    </p>

  </div>
</body>
</html>
