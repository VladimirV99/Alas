<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>IEEE Konverter</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script type="text/javascript" src="uoar_core.js"></script>
  <script type="text/javascript" src="output.js"></script>
  <script type="text/javascript" src="ieee754.js"></script>
  <script>

    function calculateBinary32(){
      var significand = toUOARNumber(document.getElementById('significand').value, 10, NumberTypes.SIGNED, false);
      var exponent = document.getElementById('exponent').value;
      clearStackTrace();
      clearOutput();
      var res = convertToIEEE754Binary32(significand, exponent);
      if(res!=null){
        document.getElementById("text1").innerHTML=output;
      }
    }

    function calculateBinary64(){
      var significand = toUOARNumber(document.getElementById('significand').value, 10, NumberTypes.SIGNED, false);
      var exponent = document.getElementById('exponent').value;
      clearStackTrace();
      clearOutput();
      var res = convertToIEEE754Binary64(significand, exponent);
      if(res!=null){
        document.getElementById("text1").innerHTML=output;
      }
    }

    function calculateDecimal32DPD(){
      var significand = toUOARNumber(document.getElementById('significand').value, 10, NumberTypes.SIGNED, false);
      var exponent = document.getElementById('exponent').value;
      clearStackTrace();
      clearOutput();
      var res = convertToIEEE754Decimal32DPD(significand, exponent);
      if(res!=null){
        document.getElementById("text1").innerHTML=output;
      }
    }

    function calculateDecimal32BID(){
      var significand = toUOARNumber(document.getElementById('significand').value, 10, NumberTypes.SIGNED, false);
      var exponent = document.getElementById('exponent').value;
      clearStackTrace();
      clearOutput();
      var res = convertToIEEE754Decimal32BID(significand, exponent);
      if(res!=null){
        document.getElementById("text1").innerHTML=output;
      }
    }

    function calculateHexadecimal32(){
      var significand = toUOARNumber(document.getElementById('significand').value, 10, NumberTypes.SIGNED, false);
      var exponent = document.getElementById('exponent').value;
      clearStackTrace();
      clearOutput();
      var res = convertToIEEE754Hexadecimal32(significand, exponent);
      if(res!=null){
        document.getElementById("text1").innerHTML=output;
      }
    }

    function convertToIEEE754Binary32(significand, exponent, standardized=false, log=true){
      if(!standardized){
        let std_significand = standardizeUOARNumber(significand, log);
        if(std_significand==null){
          addToStackTrace("convertToIEEE754Binary32", "Invalid number \"" + std_significand.toSigned() + "\" for base 2", log);
          return null;
        }
        significand = std_significand;
      }
      var work1 = "";
      var work2 = "";
      work1 = work1.concat(significand.sign + "(" + significand.toUnsigned() + ")10");
      significand = fromDecimal(significand, 2, true, log);
      work2 = work2.concat(significand.sign + "(" + significand.toUnsigned() + ")2");
      if(significand.whole.length>BINARY32_SIGNIFICAND_LENGTH){
        addToStackTrace("convertToIEEE754Binary32", "Significand out of bounds \"" + significand.toSigned() + "\"", log);
        return null;
      }else{
        significand = fractionToLength(significand, BINARY32_SIGNIFICAND_LENGTH-significand.whole.length, log);
      }

      let std_exponent = baseToDecimalInteger(exponent, 10, NumberTypes.SIGNED, false, log);
      if(std_exponent==null){
        addToStackTrace("convertToIEEE754Binary32", "Invalid number \"" + std_exponent + "\" for base 10", log);
        return null;
      }
      work1 = work1.concat(" * 2^" + std_exponent);
      work2 = work2.concat(" * 2^" + std_exponent);
      exponent = std_exponent + getNormalizeExponentBinary(significand, true, log); 
      if(!isInBounds(exponent, BINARY32_MIN_EXPONENT, BINARY32_MAX_EXPONENT)){
        addToStackTrace("convertToIEEE754Binary32", "Exponent out of bounds \"" + exponent + "\"", log);
        return null;
      }
      
      significand = normalizeBinary(significand, true, log);

      addToOutput(work1 + " = ");
      addToOutput(work2 + " = ");
      addToOutput(significand.sign + "(" + significand.toUnsigned() + ")2 * 2^" + exponent + "<br>");

      var res = "";
      if(significand.sign==MINUS){
        res = res.concat("1");
      }else{
        res = res.concat("0");
      }

      res = res.concat(SPACE);
      var temp = toLength(fromDecimal(trimSign(toUOARNumber((127+exponent).toString(), 10 , NumberTypes.SIGNED, log)), 2, true, log), BINARY32_EXPONENT_LENGTH, 0, log);
      addToOutput("eksp: " + exponent.toString() + " + " + BINARY32_EXCESS.toString() + " = " + (BINARY32_EXCESS+exponent) + " = (" + temp.toUnsigned() + ")2 <br>");
      res = res.concat(temp.toUnsigned());

      res = res.concat(SPACE);
      res = res.concat(fractionToLength(significand, BINARY32_SIGNIFICAND_LENGTH, log).fraction);

      addToOutput(res);
      return res;
    }

    function convertToIEEE754Binary64(significand, exponent, standardized=false, log=true){
      if(!standardized){
        let std_significand = standardizeUOARNumber(significand, log);
        if(std_significand==null){
          addToStackTrace("convertToIEEE754Binary64", "Invalid number \"" + std_significand.toSigned() + "\" for base 2", log);
          return null;
        }
        significand = std_significand;
      }
      var work1 = "";
      var work2 = "";
      work1 = work1.concat(significand.sign + "(" + significand.toUnsigned() + ")10");
      significand = fromDecimal(significand, 2, true, log);
      work2 = work2.concat(significand.sign + "(" + significand.toUnsigned() + ")2");
      if(significand.whole.length>BINARY64_SIGNIFICAND_LENGTH){
        addToStackTrace("convertToIEEE754Binary64", "Significand out of bounds \"" + significand.toSigned() + "\"", log);
        return null;
      }else{
        significand = fractionToLength(significand, BINARY64_SIGNIFICAND_LENGTH-significand.whole.length, log);
      }

      let std_exponent = baseToDecimalInteger(exponent, 10, NumberTypes.SIGNED, false, log);
      if(std_exponent==null){
        addToStackTrace("convertToIEEE754Binary64", "Invalid number \"" + std_exponent + "\" for base 10", log);
        return null;
      }
      work1 = work1.concat(" * 2^" + std_exponent);
      work2 = work2.concat(" * 2^" + std_exponent);
      exponent = std_exponent + getNormalizeExponentBinary(significand, true, log); 
      if(!isInBounds(exponent, BINARY64_MIN_EXPONENT, BINARY64_MAX_EXPONENT)){
        addToStackTrace("convertToIEEE754Binary64", "Exponent out of bounds \"" + exponent + "\"", log);
        return null;
      }

      significand = normalizeBinary(significand, true, log);

      addToOutput(work1 + " = ");
      addToOutput(work2 + " = ");
      addToOutput(significand.sign + "(" + significand.toUnsigned() + ")2 * 2^" + exponent + "<br>");

      var res = "";
      if(significand.sign==MINUS){
        res = res.concat("1");
      }else{
        res = res.concat("0");
      }

      res = res.concat(SPACE);
      var temp = toLength(fromDecimal(trimSign(toUOARNumber((BINARY64_EXCESS+exponent).toString(), 10 , NumberTypes.SIGNED, log)), 2, true, log), BINARY64_EXPONENT_LENGTH, 0, log);
      addToOutput("eksp: " + exponent.toString() + " + " + BINARY64_EXCESS.toString() + " = " + (BINARY64_EXCESS+exponent) + " = (" + temp.toUnsigned() + ")2 <br>");
      res = res.concat(temp.toUnsigned());

      res = res.concat(SPACE);
      res = res.concat(fractionToLength(significand, BINARY64_SIGNIFICAND_LENGTH, log).fraction);

      addToOutput(res);
      return res;
    }

    function convertToIEEE754Decimal32DPD(significand, exponent, standardized=false, log=true){
      if(!standardized){
        let std_significand = standardizeUOARNumber(significand, log);
        if(std_significand==null){
          addToStackTrace("convertToIEEE754Decimal32DPD", "Invalid number \"" + std_significand.toSigned() + "\" for base 10", log);
          return null;
        }
        significand = std_significand;
      }
      var work1 = "";
      work1 = work1.concat(significand.sign + "(" + significand.toUnsigned() + ")10");

      let std_exponent = baseToDecimalInteger(exponent, 10, NumberTypes.SIGNED, false, log);
      if(std_exponent==null){
        addToStackTrace("convertToIEEE754Decimal32DPD", "Invalid number \"" + std_exponent + "\" for base 10", log);
        return null;
      }
      work1 = work1.concat(" * 10^" + std_exponent);
      exponent = std_exponent + getNormalizeExponentDecimal(significand, true, log); 
      if(!isInBounds(exponent, DECIMAL32_MIN_EXPONENT, DECIMAL32_MAX_EXPONENT)){
        addToStackTrace("convertToIEEE754Decimal32DPD", "Exponent out of bounds \"" + exponent + "\"", log);
        return null;
      }
      
      significand = wholeToLength(normalizeDecimal(significand, true, log), DECIMAL32_DIGITS, log);
      if(significand==null){
        addToStackTrace("convertToIEEE754Decimal32DPD", "Significand out of bounds \"" + significand + "\"", log);
        return null;
      }

      addToOutput(work1 + " = ");
      addToOutput(significand.sign + "(" + significand.toUnsigned() + ")2 * 10^" + exponent + "<br>");

      var res = "";
      if(significand.sign==MINUS){
        res = res.concat("1");
      }else{
        res = res.concat("0");
      }

      res = res.concat(SPACE);
      var na = addZeroesBefore(digitToBinary(significand.whole, 0), 10, NumberTypes.UNSIGNED, 4, log);
      var nb = wholeToLength(fromDecimal(trimSign(toUOARNumber((DECIMAL32_EXCESS+exponent).toString(), 10, NumberTypes.SIGNED, log)), 2, true, log), 8, log).toUnsigned();
      addToOutput("eksp: " + exponent.toString() + " + " + DECIMAL32_EXCESS.toString() + " = " + (DECIMAL32_EXCESS+exponent) + " = (" + nb + ")2 <br>");
      if(na.charAt(0)=='0'){
        addToOutput("komb: " + nb.substr(0,2) + " " + na.substr(1,3) + " " + nb.substr(2,6) + "<br>");
        res = res.concat(nb.substr(0,2)+na.substr(1,3)+nb.substr(2,6));
      }else{
        addToOutput("komb: 11 " + nb.substr(0, 2) + na.charAt(3) + " " +nb.substr(2, 6));
        res = res.concat("11"+nb.substr(0, 2)+na.charAt(3)+nb.substr(2, 6));
      }

      res = res.concat(SPACE);
      addToOutput("<table>");
      addToOutput("<tr>");
      for(let i=1; i<=6; i++){
        addToOutput("<td>" + significand.whole.charAt(i) + "</td>");
      }
      addToOutput("</tr>");
      addToOutput("<tr>");
      for(let i=1; i<=6; i++){
        addToOutput("<td>" + addZeroesBefore(numberToBinary(significand.whole.charAt(i), log), 2, NumberTypes.UNSIGNED, 4, log) + "</td>");
      }
      addToOutput("</tr>");
      var nc1 = decimalToDPD(decimalTo8421(significand.whole.substr(1, 3)));
      var nc2 = decimalToDPD(decimalTo8421(significand.whole.substr(4, 3)));
      addToOutput("<tr><td colspan=\"3\">" + nc1 + "</td><td colspan=\"3\">" + nc2 + "</td></tr>");
      addToOutput("</table><br>");
      var nc = nc1 + nc2;
      res = res.concat(nc);

      addToOutput(res);
      return res;
    }

    function convertToIEEE754Decimal32BID(significand, exponent, standardized=false, log=true){
      if(!standardized){
        let std_significand = standardizeUOARNumber(significand, log);
        if(std_significand==null){
          addToStackTrace("convertToIEEE754Decimal32BID", "Invalid number \"" + std_significand.toSigned() + "\" for base 10", log);
          return null;
        }
        significand = std_significand;
      }
      var work1 = "";
      work1 = work1.concat(significand.sign + "(" + significand.toUnsigned() + ")10");

      let std_exponent = baseToDecimalInteger(exponent, 10, NumberTypes.SIGNED, false, log);
      if(std_exponent==null){
        addToStackTrace("convertToIEEE754Decimal32BID", "Invalid number \"" + std_exponent + "\" for base 10", log);
        return null;
      }
      work1 = work1.concat(" * 10^" + std_exponent);
      exponent = std_exponent + getNormalizeExponentDecimal(significand, true, log); 
      if(!isInBounds(exponent, DECIMAL32_MIN_EXPONENT, DECIMAL32_MAX_EXPONENT)){
        addToStackTrace("convertToIEEE754Decimal32BID", "Exponent out of bounds \"" + exponent + "\"", log);
        return null;
      }

      significand = normalizeDecimal(significand, true, log);
      if(significand==null){
        addToStackTrace("convertToIEEE754Decimal32BID", "Significand out of bounds \"" + significand.toSigned() + "\"", log);
        return null;
      }
      addToOutput(work1 + " = ");
      addToOutput(significand.sign+ "(" + significand.toUnsigned() + ")10 * 10^" + exponent + "<br>");

      significand = wholeToLength(fromDecimal(significand, 2, true, log), 1+DECIMAL32_SIGNIFICAND_LENGTH, log);
      if(significand.whole.length>25){
        addToStackTrace("convertToIEEE754Decimal32BID", "Significand out of bounds \"" + significand.toSigned() + "\"", log);
        return null;
      }
      addToOutput(significand.sign + "(" + significand.toUnsigned() + ")2 * 10^" + exponent + "<br>");      
      
      var res = "";
      if(significand.sign==MINUS){
        res = res.concat("1");
      }else{
        res = res.concat("0");
      }

      res = res.concat(SPACE);
      var na = significand.whole.substr(0,4);
      var nb = wholeToLength(fromDecimal(trimSign(toUOARNumber((DECIMAL32_EXCESS+exponent).toString(), 10, NumberTypes.SIGNED, log)), 2, true, log), 8, log).toUnsigned();
      addToOutput("eksp: " + exponent.toString() + " + " + DECIMAL32_EXCESS.toString() + " = " + (DECIMAL32_EXCESS+exponent) + " = (" + nb + ")2 <br>");
      if(na.charAt(0)=='0'){
        addToOutput("komb: " + nb + " " + na.substr(1,3) + "<br>");
        res = res.concat(nb+na.substr(1,3));
      }else{
        addToOutput("komb: 11 " + nb + " " + na.charAt(3));
        res = res.concat("11"+nb+na.charAt(3));
      }

      res = res.concat(SPACE);
      res = res.concat(significand.whole.substr(4));
      
      addToOutput(res);
      return res;
    }

    function convertToIEEE754Hexadecimal32(significand, exponent, standardized=false, log=true){
      if(!standardized){
        let std_significand = standardizeUOARNumber(significand, log);
        if(std_significand==null){
          addToStackTrace("convertToIEEE754Hexadecimal32", "Invalid number \"" + std_significand.toSigned() + "\" for base 10", log);
          return null;
        }
        significand = std_significand;
      }
      var work1 = "";
      var work2 = "";
      work1 = work1.concat(significand.sign + "(" + significand.toUnsigned() + ")10");
      significand = fromDecimal(significand, 16, true, log);
      work2 = work2.concat(significand.sign + "(" + significand.toUnsigned() + ")16");
      if(significand.whole.length>6){
        addToStackTrace("convertToIEEE754Hexadecimal32", "Significand out of bounds \"" + significand.toSigned() + "\"", log);
        return null;
      }else{
        significand = fractionToLength(significand, 6-significand.whole.length, log);
      }

      let std_exponent = baseToDecimalInteger(exponent, 10, NumberTypes.SIGNED, false, log);
      if(std_exponent==null){
        addToStackTrace("convertToIEEE754Hexadecimal32", "Invalid number \"" + std_exponent + "\" for base 10", log);
        return null;
      }
      work1 = work1.concat(" * 16^" + std_exponent);
      work2 = work2.concat(" * 16^" + std_exponent);
      exponent = std_exponent + getNormalizeExponentHexadecimal(significand, true, log); 
      if(!isInBounds(exponent, HEXADECIMAL32_MIN_EXPONENT, HEXADECIMAL32_MAX_EXPONENT)){
        addToStackTrace("convertToIEEE754Hexadecimal32", "Exponent out of bounds \"" + exponent + "\"", log);
        return null;
      }

      significand = normalizeHexadecimal(significand, true, log);

      addToOutput(work1 + " = ");
      addToOutput(work2 + " = ");
      addToOutput(significand.sign + "(" + significand.toUnsigned() + ")16 * 16^" + exponent + "<br>");

      var res = "";
      if(significand.sign==MINUS){
        res = res.concat("1");
      }else{
        res = res.concat("0");
      }

      res = res.concat(SPACE);
      var temp = toLength(fromDecimal(trimSign(toUOARNumber((HEXADECIMAL32_EXCESS+exponent).toString(), 10, NumberTypes.SIGNED, log)), 2, true, log), HEXADECIMAL32_EXPONENT_LENGTH, 0, log).toUnsigned();
      addToOutput("eksp: " + exponent.toString() + " + " + HEXADECIMAL32_EXCESS + " = " + (HEXADECIMAL32_EXCESS+exponent) + " = (" + temp + ")2 <br>");
      res = res.concat(temp);

      res = res.concat(SPACE);
      res = res.concat(decimalTo8421(significand.fraction));

      addToOutput(res);
      return res;
    }

    function calculateDecimalBinary32(){
      var ieee = document.getElementById('ieee').value;
      clearStackTrace();
      clearOutput();
      var res = convertFromIEEE754Binary32(ieee);
      if(res!=null){
        document.getElementById("text2").innerHTML=output;
      }
    }

    function calculateDecimalBinary64(){
      var ieee = document.getElementById('ieee').value;
      clearStackTrace();
      clearOutput();
      var res = convertFromIEEE754Binary64(ieee);
      if(res!=null){
        document.getElementById("text2").innerHTML=output;
      }
    }

    function calculateDecimalDecimal32DPD(){
      var ieee = document.getElementById('ieee').value;
      clearStackTrace();
      clearOutput();
      var res = convertFromIEEE754Decimal32DPD(ieee);
      if(res!=null){
        document.getElementById("text2").innerHTML=output;
      }
    }

    function calculateDecimalDecimal32BID(){
      var ieee = document.getElementById('ieee').value;
      clearStackTrace();
      clearOutput();
      var res = convertFromIEEE754Decimal32BID(ieee);
      if(res!=null){
        document.getElementById("text2").innerHTML=output;
      }
    }

    function calculateDecimalHexadecimal32(){
      var ieee = document.getElementById('ieee').value;
      clearStackTrace();
      clearOutput();
      var res = convertFromIEEE754Hexadecimal32(ieee);
      if(res!=null){
        document.getElementById("text2").innerHTML=output;
      }
    }

    function convertFromIEEE754Binary32(number, log=true){
      if(!isValidIEEE754(number, 32)){
        addToStackTrace("convertFromIEEE754Binary32", "Invalid IEEE754 Binary32 number \"" + number + "\"", log);
        return null;
      }

      var res = getSpecialValueBinary32(number);
      if(res!=null){
        addToOutput("specijalna vrednost: " + res.value + "<br>");
        return res;
      }

      var sign = "";
      if(number.charAt(0)=="1"){
        sign = MINUS;
      }else{
        sign = PLUS;
      }

      var significand;
      var exponent = baseToDecimalInteger(number.substr(1, BINARY32_EXPONENT_LENGTH), 2, NumberTypes.UNSIGNED, log);
      addToOutput("eksp: (" + number.substr(1, BINARY32_EXPONENT_LENGTH) + ")2 - " + BINARY32_EXCESS.toString() + " = " + exponent + " - " + BINARY32_EXCESS.toString() + " = ");
      exponent -= BINARY32_EXCESS;
      addToOutput(exponent + "<br>");

      if(exponent==-BINARY32_EXCESS){
        addToOutput("subnormalan broj<br>");
        let temp = trimNumber(new UOARNumber(sign, "0", number.substr(1+BINARY32_EXPONENT_LENGTH, BINARY32_SIGNIFICAND_LENGTH), 2, NumberTypes.SIGNED));
        exponent += 1+getNormalizeExponentBinary(temp, true, log);
        significand = normalizeBinary(temp);
        addToOutput("(" + temp.toSigned() + ")2 * 2^" + exponent + " = (" + significand.toSigned() + ")2 * 2^" + exponent + "<br>");
      }else{
        significand = trimNumber(new UOARNumber(sign, "1", number.substr(1+BINARY32_EXPONENT_LENGTH, BINARY32_SIGNIFICAND_LENGTH), 2, NumberTypes.SIGNED));
        addToOutput("frakc: (" + significand.toSigned() + ")2<br>");
      }

      addToOutput("(" + significand.toSigned() + ")2 * 2^" + exponent + " = ");

      let whole = significand.whole!="0";
      let len = (whole? 1 : 0) + significand.fraction.length;
      if(len!=1){
        if(!whole)
          significand.whole="";
        if(exponent>=0 && exponent<10){
          significand.whole = significand.whole.concat(significand.fraction.substr(0, exponent));
          significand.fraction = significand.fraction.substr(exponent);
          exponent = 0;
        }else{
          if(len<9){
            exponent -= significand.fraction.length;
            significand.whole = significand.whole.concat(significand.fraction);
            significand.fraction = "";
          }else if(len<14){
            exponent -= 8-(whole? 1 : 0);
            significand.whole = significand.whole.concat(significand.fraction.substr(0, 8-(whole? 1 : 0)));
            significand.fraction = significand.fraction.substr(8-(whole? 1 : 0));
          }else{
            exponent -= len-5-(whole? 1 : 0);
            significand.whole = significand.whole.concat(significand.fraction.substr(0, len-5-(whole? 1 : 0)));
            significand.fraction = significand.fraction.substr(len-5-(whole? 1 : 0));
          }
        }
      }

      significand = toDecimal(significand, true, log);

      res = {"significand": significand, "exponent": exponent, "special": false};
      addToOutput("(" + significand.toSigned() + ")2 * 2^" + exponent + "<br>");
      return res;
    }

    function convertFromIEEE754Binary64(number, log=true){
      if(!isValidIEEE754(number, 64)){
        addToStackTrace("convertFromIEEE754Binary64", "Invalid IEEE754 Binary64 number \"" + number + "\"", log);
        return null;
      }

      var res = getSpecialValueBinary64(number);
      if(res!=null){
        addToOutput("specijalna vrednost: " + res.value + "<br>");
        return res;
      }

      var sign = "";
      if(number.charAt(0)=="1"){
        sign = MINUS;
      }else{
        sign = PLUS;
      }

      var significand;
      var exponent = baseToDecimalInteger(number.substr(1, BINARY64_EXPONENT_LENGTH), 2, NumberTypes.UNSIGNED, log);
      addToOutput("eksp: (" + number.substr(1, BINARY64_EXPONENT_LENGTH) + ")2 - " + BINARY64_EXCESS + " = " + exponent + " - " + BINARY64_EXCESS + " = ");
      exponent -= BINARY64_EXCESS;
      addToOutput(exponent + "<br>");

      if(exponent==-BINARY64_EXCESS){
        addToOutput("subnormalan broj<br>");
        let temp = trimNumber(new UOARNumber(sign, "0", number.substr(1+BINARY64_EXPONENT_LENGTH, BINARY64_SIGNIFICAND_LENGTH), 2, NumberTypes.SIGNED));
        exponent += 1+getNormalizeExponentBinary(temp, true, log);
        significand = normalizeBinary(temp);
        addToOutput("(" + temp.toSigned() + ")2 * 2^" + exponent + " = (" + significand.toSigned() + ")2 * 2^" + exponent + "<br>");
      }else{
        significand = trimNumber(new UOARNumber(sign, "1", number.substr(1+BINARY64_EXPONENT_LENGTH, BINARY64_SIGNIFICAND_LENGTH), 2, NumberTypes.SIGNED));
        addToOutput("frakc: (" + significand.toSigned() + ")2<br>");
      }

      addToOutput("(" + significand.toSigned() + ")2 * 2^" + exponent + " = ");

      let whole = significand.whole!="0";
      let len = (whole? 1 : 0) + significand.fraction.length;
      if(len!=1){
        if(!whole)
          significand.whole="";
        if(exponent>=0 && exponent<10){
          significand.whole = significand.whole.concat(significand.fraction.substr(0, exponent));
          significand.fraction = significand.fraction.substr(exponent);
          exponent = 0;
        }else{
          if(len<9){
            exponent -= significand.fraction.length;
            significand.whole = significand.whole.concat(significand.fraction);
            significand.fraction = "";
          }else if(len<14){
            exponent -= 8-(whole? 1 : 0);
            significand.whole = significand.whole.concat(significand.fraction.substr(0, 8-(whole? 1 : 0)));
            significand.fraction = significand.fraction.substr(8-(whole? 1 : 0));
          }else{
            exponent -= len-5-(whole? 1 : 0);
            significand.whole = significand.whole.concat(significand.fraction.substr(0, len-5-(whole? 1 : 0)));
            significand.fraction = significand.fraction.substr(len-5-(whole? 1 : 0));
          }
        }
      }

      significand = toDecimal(significand, true, log);

      res = {"significand": significand, "exponent": exponent, "special": false};
      addToOutput("(" + significand.toSigned() + ")2 * 2^" + exponent + "<br>");
      return res;
    }

    function convertFromIEEE754Decimal32DPD(number, log=true){
      if(!isValidIEEE754(number, 32)){
        addToStackTrace("convertFromIEEE754Decimal32DPD", "Invalid IEEE754 Decimal32 number \"" + number + "\"", log);
        return null;
      }

      var res = getSpecialValueDecimal32(number);
      if(res!=null){
        addToOutput("specijalna vrednost: " + res.value + "<br>");
        return res;
      }

      var sign = "";
      if(number.charAt(0)=="1"){
        sign = MINUS;
      }else{
        sign = PLUS;
      }

      var significand;
      var comb = "";
      if(number.substr(1, 2)=="11"){
        significand = "100" + number.charAt(5);
        comb = number.substr(3, 2) + number.substr(6, 6);
      }else{
        significand = "0" + number.substr(3, 3);
        comb = number.substr(1,2) + number.substr(6, 6);
      }

      var exponent = baseToDecimalInteger(comb, 2, NumberTypes.UNSIGNED, log);
      if(exponent==0){
        addToOutput("subnormalan broj<br>");
        exponent = -101 - DECIMAL_LENGTH;
        addToOutput("eksp: " + exponent + "<br>");
      }else{
        addToOutput("eksp: (" + comb + ")2 - " + DECIMAL32_EXCESS + " = " + exponent + " - " + DECIMAL32_EXCESS + " = ");
        exponent -= DECIMAL32_EXCESS;
        addToOutput(exponent + "<br>");
      }

      let dpd1 = DPDtoDecimal(number.substr(1+DECIMAL32_EXPONENT_LENGTH, DECIMAL32_TRIPLET_LENGTH), log);
      let dpd2 = DPDtoDecimal(number.substr(1+DECIMAL32_EXPONENT_LENGTH+DECIMAL32_TRIPLET_LENGTH, DECIMAL32_TRIPLET_LENGTH), log);
      addToOutput("frakc: (" + significand + " " + dpd1 + " " + dpd2 + ")2 = ");

      addToOutput("(" + significand + " " + dpd1 + " " + dpd2 + ")2 = ");
      significand = significand + dpd1 + dpd2;
      significand = trimNumber(new UOARNumber(sign, decimalFrom8421(significand, log), "", 10, NumberTypes.SIGNED));
      addToOutput("(" + significand.toUnsigned() + ")10 <br>");

      addToOutput("(" + significand.toSigned() + ")10 * 10^" + exponent);

      let normalize_exponent = getNormalizeExponentDecimal(significand, true, log);
      if(normalize_exponent>0){
        exponent += normalize_exponent;
        significand = normalizeDecimal(significand, true, log);
        addToOutput(" = (" + significand.toSigned() + ")10 * 10^" + exponent + "<br>");
      }

      res = {"significand": significand, "exponent": exponent, "special": false};
      return res;
    }

    function convertFromIEEE754Decimal32BID(number, log=true){
      if(!isValidIEEE754(number, 32)){
        addToStackTrace("convertFromIEEE754Decimal32BID", "Invalid IEEE754 Decimal32 number \"" + number + "\"", log);
        return null;
      }

      var res = getSpecialValueDecimal32(number);
      if(res!=null){
        addToOutput("specijalna vrednost: " + res.value + "<br>");
        return res;
      }

      var sign = "";
      if(number.charAt(0)=="1"){
        sign = MINUS;
      }else{
        sign = PLUS;
      }

      var significand;
      var comb = "";
      if(number.substr(1, 2)=="11"){
        significand = "100" + number.charAt(11);
        comb = number.substr(3, 8);
      }else{
        significand = "0" + number.substr(9, 3);
        comb = number.substr(1, 8);
      }

      var exponent = baseToDecimalInteger(comb, 2, NumberTypes.UNSIGNED, log);
      if(exponent==0){
        addToOutput("subnormalan broj<br>");
        exponent = -DECIMAL32_EXCESS - DECIMAL_LENGTH;
        addToOutput("eksp: " + exponent + "<br>");
      }else{
        addToOutput("eksp: (" + comb + ")2 - " + DECIMAL32_EXCESS + " = " + exponent + " - " + DECIMAL32_EXCESS + " = ");
        exponent -= DECIMAL32_EXCESS;
        addToOutput(exponent + "<br>");
      }

      addToOutput("frakc: (" + significand + " " + number.substr(12, 20) + ")2 = ");

      significand = significand + number.substr(1+DECIMAL32_EXPONENT_LENGTH, DECIMAL32_SIGNIFICAND_LENGTH);
      significand = trimNumber(toDecimal(new UOARNumber(sign, significand, "", 2, NumberTypes.SIGNED), false, log));
      addToOutput("(" + significand.toUnsigned() + ")10 <br>");

      addToOutput("(" + significand.toSigned() + ")10 * 10^" + exponent);

      let normalize_exponent = getNormalizeExponentDecimal(significand, true, log);
      if(normalize_exponent>0){
        exponent += normalize_exponent;
        significand = normalizeDecimal(significand, true, log);
        addToOutput(" = (" + significand.toSigned() + ")10 * 10^" + exponent + "<br>");
      }

      res = {"significand": significand, "exponent": exponent, "special": false};
      return res;
    }

    function convertFromIEEE754Hexadecimal32(number, log=true){
      if(!isValidIEEE754(number, 32)){
        addToStackTrace("convertFromIEEE754Hexadecimal32", "Invalid IEEE754 Hexadecimal32 number \"" + number + "\"", log);
        return null;
      }

      var sign = "";
      if(number.charAt(0)=="1"){
        sign = MINUS;
      }else{
        sign = PLUS;
      }

      var exponent = baseToDecimalInteger(number.substr(1, HEXADECIMAL32_EXPONENT_LENGTH), 2, NumberTypes.UNSIGNED, log);
      addToOutput("eksp: (" + number.substr(1, HEXADECIMAL32_EXPONENT_LENGTH) + ")2 - " + HEXADECIMAL32_EXCESS.toString() + " = " + exponent + " - " + HEXADECIMAL32_EXCESS + " = ");
      exponent -= HEXADECIMAL32_EXCESS;
      addToOutput(exponent + "<br>");

      significand = trimNumber(new UOARNumber(sign, "0", decimalFrom8421(number.substr(1+HEXADECIMAL32_EXPONENT_LENGTH, HEXADECIMAL32_SIGNIFICAND_LENGTH)), 16, NumberTypes.SIGNED));
      addToOutput("frakc: (0." + number.substr(1+HEXADECIMAL32_EXPONENT_LENGTH, HEXADECIMAL32_SIGNIFICAND_LENGTH) + ")2 = (" + significand.toUnsigned() + ")16 <br>");

      addToOutput("(" + significand.toUnsigned() + ")16 * 16^" + exponent + " = ");

      let len = significand.fraction.length;
      if(exponent>=0 && exponent<6){
        significand.whole = significand.fraction.substr(0, exponent);
        significand.fraction = significand.fraction.substr(exponent);
        exponent = 0;
      }else{
        if(len<6){
          exponent += significand.fraction.length;
          significand.whole = significand.fraction;
          significand.fraction = "";
        }else if(len<9){
          exponent -= 6;
          significand.whole = significand.fraction.substr(0, 6);
          significand.fraction = significand.fraction.substr(6);
        }else{
          exponent -= len-3;
          significand.whole = significand.fraction.substr(0, len-3);
          significand.fraction = significand.fraction.substr(len-3);
        }
      }

      addToOutput("(" + significand.toUnsigned() + ")16 * 16^" + exponent + " = ");
      significand = toDecimal(significand, false, log);
      addToOutput("(" + significand.toUnsigned() + ")10 * 16^" + exponent);

      res = {"significand": significand, "exponent": exponent, "special": false};
      return res;
    }

    function test(){
    }
  </script>
</head>
<body>

  <div class="container" id="main">
    <p>significand</p>
    <input type="text" id="significand"></input>
    <p>exponent</p>
    <input type="number" id="exponent"></input>
    <br><br>
    <input value="Izracunaj binary32" type="button" name="calc" id="calc" onclick="calculateBinary32()"></input>
    <input value="Izracunaj binary64" type="button" name="calc2" id="calc2" onclick="calculateBinary64()"></input>
    <input value="Izracunaj decimal32 DPD" type="button" name="calc3" id="calc3" onclick="calculateDecimal32DPD()"></input>
    <input value="Izracunaj decimal32 BID" type="button" name="calc4" id="calc4" onclick="calculateDecimal32BID()"></input>
    <input value="Izracunaj hexadecimal32" type="button" name="calc5" id="calc5" onclick="calculateHexadecimal32()"></input>

    <p id="text1">
      resenje
    </p>

    <input value="Test" type="button" name="test" id="test" onclick="test()"></input>

    <hr>

    <input type="text" name="ieee" id="ieee"></input>
    <input type="button" name="calc6" id = "calc6" value="From binary32" onclick="calculateDecimalBinary32()"></input>
    <input type="button" name="calc7" id = "calc7" value="From binary64" onclick="calculateDecimalBinary64()"></input>
    <input type="button" name="calc8" id = "calc8" value="From decimal32 DPD" onclick="calculateDecimalDecimal32DPD()"></input>
    <input type="button" name="calc9" id = "calc9" value="From decimal32 BID" onclick="calculateDecimalDecimal32BID()"></input>
    <input type="button" name="calc10" id = "calc10" value="From hexadecimal32" onclick="calculateDecimalHexadecimal32()"></input>

    <p id="text2">
      resenje
    </p>

  </div>
</body>
</html>
